.TH "/Users/maximilian/clang-llvm/clang/tools/c-index-test/c-index-test.c" 3 "Sat Feb 12 2022" "Version 1.2" "Regions Of Interest (ROI) Profiler" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/Users/maximilian/clang-llvm/clang/tools/c-index-test/c-index-test.c
.SH SYNOPSIS
.br
.PP
\fC#include 'clang/Config/config\&.h'\fP
.br
\fC#include 'clang\-c/Index\&.h'\fP
.br
\fC#include 'clang\-c/CXCompilationDatabase\&.h'\fP
.br
\fC#include 'clang\-c/BuildSystem\&.h'\fP
.br
\fC#include 'clang\-c/Documentation\&.h'\fP
.br
\fC#include <ctype\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <assert\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBCommentASTDumpingContext\fP"
.br
.ti -1c
.RI "struct \fBLineCol\fP"
.br
.ti -1c
.RI "struct \fBVisitorData\fP"
.br
.ti -1c
.RI "struct \fBCursorSourceLocation\fP"
.br
.ti -1c
.RI "struct \fBImportedASTFilesData\fP"
.br
.ti -1c
.RI "struct \fBIndexDataStringList_\fP"
.br
.ti -1c
.RI "struct \fBIndexData\fP"
.br
.ti -1c
.RI "struct \fBthread_info\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBPRINT_PROP_ATTR\fP(A)             if (PropAttrs & CXObjCPropertyAttr_##A) printf(#A ',')"
.br
.ti -1c
.RI "#define \fBPRINT_OBJC_QUAL\fP(A)             if (QT & CXObjCDeclQualifier_##A) printf(#A ',')"
.br
.ti -1c
.RI "#define \fBMAX_IMPORTED_ASTFILES\fP   200"
.br
.ti -1c
.RI "#define \fBMAX_COMPILE_ARGS\fP   512"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(* \fBPostVisitTU\fP) (CXTranslationUnit)"
.br
.ti -1c
.RI "typedef void(* \fBcursor_handler_t\fP) (CXCursor cursor)"
.br
.ti -1c
.RI "typedef struct \fBIndexDataStringList_\fP \fBIndexDataStringList\fP"
.br
.ti -1c
.RI "typedef struct \fBthread_info\fP \fBthread_info\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBDisplayType\fP { \fBDisplayType_Spelling\fP, \fBDisplayType_DisplayName\fP, \fBDisplayType_Pretty\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBindextest_core_main\fP (int argc, const char **argv)"
.br
.ti -1c
.RI "int \fBindextest_perform_shell_execution\fP (const char *command_line)"
.br
.ti -1c
.RI "char * \fBbasename\fP (const char *)"
.br
.ti -1c
.RI "char * \fBdirname\fP (char *)"
.br
.ti -1c
.RI "void \fBfree_remapped_files\fP (struct CXUnsavedFile *unsaved_files, int num_unsaved_files)"
.br
.ti -1c
.RI "void \fBPrintDiagnostic\fP (CXDiagnostic Diagnostic)"
.br
.ti -1c
.RI "void \fBPrintDiagnosticSet\fP (CXDiagnosticSet Set)"
.br
.ti -1c
.RI "void \fBPrintDiagnostics\fP (CXTranslationUnit TU)"
.br
.ti -1c
.RI "void \fBPrintMemoryUsage\fP (CXTranslationUnit TU)"
.br
.ti -1c
.RI "enum CXChildVisitResult \fBFilteredPrintingVisitor\fP (CXCursor Cursor, CXCursor Parent, CXClientData ClientData)"
.br
.ti -1c
.RI "enum CXChildVisitResult \fBUSRVisitor\fP (CXCursor C, CXCursor parent, CXClientData ClientData)"
.br
.ti -1c
.RI "void \fBInclusionVisitor\fP (CXFile includedFile, CXSourceLocation *includeStack, unsigned includeStackLen, CXClientData data)"
.br
.ti -1c
.RI "void \fBPrintInclusionStack\fP (CXTranslationUnit TU)"
.br
.ti -1c
.RI "int \fBperform_test_load_tu\fP (const char *file, const char *filter, const char *prefix, CXCursorVisitor Visitor, \fBPostVisitTU\fP PV)"
.br
.ti -1c
.RI "int \fBperform_test_load_source\fP (int argc, const char **argv, const char *filter, CXCursorVisitor Visitor, \fBPostVisitTU\fP PV)"
.br
.ti -1c
.RI "int \fBperform_test_reparse_source\fP (int argc, const char **argv, int trials, const char *filter, CXCursorVisitor Visitor, \fBPostVisitTU\fP PV)"
.br
.ti -1c
.RI "int \fBparse_file_line_column\fP (const char *input, char **filename, unsigned *line, unsigned *column, unsigned *second_line, unsigned *second_column)"
.br
.ti -1c
.RI "const char * \fBclang_getCompletionChunkKindSpelling\fP (enum CXCompletionChunkKind Kind)"
.br
.ti -1c
.RI "void \fBprint_completion_contexts\fP (unsigned long long contexts, FILE *file)"
.br
.ti -1c
.RI "int \fBperform_code_completion\fP (int argc, const char **argv, int timing_only)"
.br
.ti -1c
.RI "int \fBperform_token_annotation\fP (int argc, const char **argv)"
.br
.ti -1c
.RI "int \fBprint_usrs\fP (const char **I, const char **E)"
.br
.ti -1c
.RI "int \fBprint_usrs_file\fP (const char *file_name)"
.br
.ti -1c
.RI "int \fBwrite_pch_file\fP (const char *filename, int argc, const char *argv[])"
.br
.ti -1c
.RI "int \fBcindextest_main\fP (int argc, const char **argv)"
.br
.ti -1c
.RI "void \fBthread_runner\fP (void *client_data_v)"
.br
.ti -1c
.RI "int \fBmain\fP (int argc, const char **argv)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define MAX_COMPILE_ARGS   512"

.SS "#define MAX_IMPORTED_ASTFILES   200"

.PP
Definition at line 3312 of file c\-index\-test\&.c\&.
.SS "#define PRINT_OBJC_QUAL(A)             if (QT & CXObjCDeclQualifier_##A) printf(#A ',')"

.SS "#define PRINT_PROP_ATTR(A)             if (PropAttrs & CXObjCPropertyAttr_##A) printf(#A ',')"

.SH "Typedef Documentation"
.PP 
.SS "typedef void(* cursor_handler_t) (CXCursor cursor)"

.PP
Definition at line 2811 of file c\-index\-test\&.c\&.
.SS "typedef struct \fBIndexDataStringList_\fP \fBIndexDataStringList\fP"

.SS "typedef void(* PostVisitTU) (CXTranslationUnit)"

.PP
Definition at line 1187 of file c\-index\-test\&.c\&.
.SS "typedef struct \fBthread_info\fP \fBthread_info\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBDisplayType\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIDisplayType_Spelling \fP\fP
.TP
\fB\fIDisplayType_DisplayName \fP\fP
.TP
\fB\fIDisplayType_Pretty \fP\fP
.PP
Definition at line 435 of file c\-index\-test\&.c\&.
.PP
.nf
435                         {
436     DisplayType_Spelling,
437     DisplayType_DisplayName,
438     DisplayType_Pretty
439 } wanted_display_type = DisplayType_Spelling;
.fi
.SH "Function Documentation"
.PP 
.SS "char* basename (const char *)"

.SS "int cindextest_main (int argc, const char ** argv)"

.PP
Definition at line 4861 of file c\-index\-test\&.c\&.
.PP
.nf
4861                                                  {
4862   clang_enableStackTraces();
4863   if (argc > 2 && strcmp(argv[1], "-read-diagnostics") == 0)
4864       return read_diagnostics(argv[2]);
4865   if (argc > 2 && strstr(argv[1], "-code-completion-at=") == argv[1])
4866     return perform_code_completion(argc, argv, 0);
4867   if (argc > 2 && strstr(argv[1], "-code-completion-timing=") == argv[1])
4868     return perform_code_completion(argc, argv, 1);
4869   if (argc > 2 && strstr(argv[1], "-cursor-at=") == argv[1])
4870     return inspect_cursor_at(argc, argv, "-cursor-at=", inspect_print_cursor);
4871   if (argc > 2 && strstr(argv[1], "-evaluate-cursor-at=") == argv[1])
4872     return inspect_cursor_at(argc, argv, "-evaluate-cursor-at=",
4873                              inspect_evaluate_cursor);
4874   if (argc > 2 && strstr(argv[1], "-get-macro-info-cursor-at=") == argv[1])
4875     return inspect_cursor_at(argc, argv, "-get-macro-info-cursor-at=",
4876                              inspect_macroinfo_cursor);
4877   if (argc > 2 && strstr(argv[1], "-file-refs-at=") == argv[1])
4878     return find_file_refs_at(argc, argv);
4879   if (argc > 2 && strstr(argv[1], "-file-includes-in=") == argv[1])
4880     return find_file_includes_in(argc, argv);
4881   if (argc > 2 && strcmp(argv[1], "-index-file") == 0)
4882     return index_file(argc - 2, argv + 2, /*full=*/0);
4883   if (argc > 2 && strcmp(argv[1], "-index-file-full") == 0)
4884     return index_file(argc - 2, argv + 2, /*full=*/1);
4885   if (argc > 2 && strcmp(argv[1], "-index-tu") == 0)
4886     return index_tu(argc - 2, argv + 2);
4887   if (argc > 2 && strcmp(argv[1], "-index-compile-db") == 0)
4888     return index_compile_db(argc - 2, argv + 2);
4889   else if (argc >= 4 && strncmp(argv[1], "-test-load-tu", 13) == 0) {
4890     CXCursorVisitor I = GetVisitor(argv[1] + 13);
4891     if (I)
4892       return perform_test_load_tu(argv[2], argv[3], argc >= 5 ? argv[4] : 0, I,
4893                                   NULL);
4894   }
4895   else if (argc >= 5 && strncmp(argv[1], "-test-load-source-reparse", 25) == 0){
4896     CXCursorVisitor I = GetVisitor(argv[1] + 25);
4897     if (I) {
4898       int trials = atoi(argv[2]);
4899       return perform_test_reparse_source(argc - 4, argv + 4, trials, argv[3], I, 
4900                                          NULL);
4901     }
4902   }
4903   else if (argc >= 4 && strncmp(argv[1], "-test-load-source", 17) == 0) {
4904     CXCursorVisitor I = GetVisitor(argv[1] + 17);
4905     
4906     PostVisitTU postVisit = 0;
4907     if (strstr(argv[1], "-memory-usage"))
4908       postVisit = PrintMemoryUsage;
4909     
4910     if (I)
4911       return perform_test_load_source(argc - 3, argv + 3, argv[2], I,
4912                                       postVisit);
4913   }
4914   else if (argc >= 3 && strcmp(argv[1], "-single-file-parse") == 0)
4915     return perform_single_file_parse(argv[2]);
4916   else if (argc >= 3 && strcmp(argv[1], "-retain-excluded-conditional-blocks") == 0)
4917     return perform_file_retain_excluded_cb(argv[2]);
4918   else if (argc >= 4 && strcmp(argv[1], "-test-file-scan") == 0)
4919     return perform_file_scan(argv[2], argv[3],
4920                              argc >= 5 ? argv[4] : 0);
4921   else if (argc > 2 && strstr(argv[1], "-test-annotate-tokens=") == argv[1])
4922     return perform_token_annotation(argc, argv);
4923   else if (argc > 2 && strcmp(argv[1], "-test-inclusion-stack-source") == 0)
4924     return perform_test_load_source(argc - 2, argv + 2, "all", NULL,
4925                                     PrintInclusionStack);
4926   else if (argc > 2 && strcmp(argv[1], "-test-inclusion-stack-tu") == 0)
4927     return perform_test_load_tu(argv[2], "all", NULL, NULL,
4928                                 PrintInclusionStack);
4929   else if (argc > 2 && strcmp(argv[1], "-test-print-linkage-source") == 0)
4930     return perform_test_load_source(argc - 2, argv + 2, "all", PrintLinkage,
4931                                     NULL);
4932   else if (argc > 2 && strcmp(argv[1], "-test-print-visibility") == 0)
4933     return perform_test_load_source(argc - 2, argv + 2, "all", PrintVisibility,
4934                                     NULL);
4935   else if (argc > 2 && strcmp(argv[1], "-test-print-type") == 0)
4936     return perform_test_load_source(argc - 2, argv + 2, "all",
4937                                     PrintType, 0);
4938   else if (argc > 2 && strcmp(argv[1], "-test-print-type-size") == 0)
4939     return perform_test_load_source(argc - 2, argv + 2, "all",
4940                                     PrintTypeSize, 0);
4941   else if (argc > 2 && strcmp(argv[1], "-test-print-type-declaration") == 0)
4942     return perform_test_load_source(argc - 2, argv + 2, "all",
4943                                     PrintTypeDeclaration, 0);
4944   else if (argc > 2 && strcmp(argv[1], "-test-print-decl-attributes") == 0)
4945     return perform_test_load_source(argc - 2, argv + 2, "all",
4946                                     PrintDeclAttributes, 0);
4947   else if (argc > 2 && strcmp(argv[1], "-test-print-bitwidth") == 0)
4948     return perform_test_load_source(argc - 2, argv + 2, "all",
4949                                     PrintBitWidth, 0);
4950   else if (argc > 2 && strcmp(argv[1], "-test-print-mangle") == 0)
4951     return perform_test_load_tu(argv[2], "all", NULL, PrintMangledName, NULL);
4952   else if (argc > 2 && strcmp(argv[1], "-test-print-manglings") == 0)
4953     return perform_test_load_tu(argv[2], "all", NULL, PrintManglings, NULL);
4954   else if (argc > 2 && strcmp(argv[1], "-test-print-target-info") == 0)
4955     return print_target_info(argc - 2, argv + 2);
4956   else if (argc > 1 && strcmp(argv[1], "-print-usr") == 0) {
4957     if (argc > 2)
4958       return print_usrs(argv + 2, argv + argc);
4959     else {
4960       display_usrs();
4961       return 1;
4962     }
4963   }
4964   else if (argc > 2 && strcmp(argv[1], "-print-usr-file") == 0)
4965     return print_usrs_file(argv[2]);
4966   else if (argc > 2 && strcmp(argv[1], "-write-pch") == 0)
4967     return write_pch_file(argv[2], argc - 3, argv + 3);
4968   else if (argc > 2 && strcmp(argv[1], "-compilation-db") == 0)
4969     return perform_test_compilation_db(argv[argc-1], argc - 3, argv + 2);
4970   else if (argc == 2 && strcmp(argv[1], "-print-build-session-timestamp") == 0)
4971     return perform_print_build_session_timestamp();
4972 
4973   print_usage();
4974   return 1;
4975 }
.fi
.PP
References clang_enableStackTraces()\&.
.SS "const char* clang_getCompletionChunkKindSpelling (enum CXCompletionChunkKind Kind)"

.PP
Definition at line 2393 of file c\-index\-test\&.c\&.
.PP
.nf
2393                                                                       {
2394   switch (Kind) {
2395   case CXCompletionChunk_Optional: return "Optional";
2396   case CXCompletionChunk_TypedText: return "TypedText";
2397   case CXCompletionChunk_Text: return "Text";
2398   case CXCompletionChunk_Placeholder: return "Placeholder";
2399   case CXCompletionChunk_Informative: return "Informative";
2400   case CXCompletionChunk_CurrentParameter: return "CurrentParameter";
2401   case CXCompletionChunk_LeftParen: return "LeftParen";
2402   case CXCompletionChunk_RightParen: return "RightParen";
2403   case CXCompletionChunk_LeftBracket: return "LeftBracket";
2404   case CXCompletionChunk_RightBracket: return "RightBracket";
2405   case CXCompletionChunk_LeftBrace: return "LeftBrace";
2406   case CXCompletionChunk_RightBrace: return "RightBrace";
2407   case CXCompletionChunk_LeftAngle: return "LeftAngle";
2408   case CXCompletionChunk_RightAngle: return "RightAngle";
2409   case CXCompletionChunk_Comma: return "Comma";
2410   case CXCompletionChunk_ResultType: return "ResultType";
2411   case CXCompletionChunk_Colon: return "Colon";
2412   case CXCompletionChunk_SemiColon: return "SemiColon";
2413   case CXCompletionChunk_Equal: return "Equal";
2414   case CXCompletionChunk_HorizontalSpace: return "HorizontalSpace";
2415   case CXCompletionChunk_VerticalSpace: return "VerticalSpace";
2416   }
2417 
2418   return "Unknown";
2419 }
.fi
.SS "char* dirname (char *)"

.SS "enum CXChildVisitResult FilteredPrintingVisitor (CXCursor Cursor, CXCursor Parent, CXClientData ClientData)"

.PP
Definition at line 1284 of file c\-index\-test\&.c\&.
.PP
.nf
1299                                                                          {
1300   VisitorData *Data = (VisitorData *)ClientData;
1301   if (!Data->Filter || (Cursor\&.kind == *(enum CXCursorKind *)Data->Filter)) {
1302     CXSourceLocation Loc = clang_getCursorLocation(Cursor);
1303     unsigned line, column;
1304     clang_getSpellingLocation(Loc, 0, &line, &column, 0);
1305     printf("// %s: %s:%d:%d: ", FileCheckPrefix,
1306            GetCursorSource(Cursor), line, column);
1307     PrintCursor(Cursor, Data->CommentSchemaFile);
1308     PrintCursorExtent(Cursor);
1309     if (clang_isDeclaration(Cursor\&.kind)) {
1310       enum CX_CXXAccessSpecifier access = clang_getCXXAccessSpecifier(Cursor);
1311       const char *accessStr = 0;
1312 
1313       switch (access) {
1314         case CX_CXXInvalidAccessSpecifier: break;
1315         case CX_CXXPublic:
1316           accessStr = "public"; break;
1317         case CX_CXXProtected:
1318           accessStr = "protected"; break;
1319         case CX_CXXPrivate:
1320           accessStr = "private"; break;
1321       }
1322 
1323       if (accessStr)
1324         printf(" [access=%s]", accessStr);
1325     }
1326     printf("\n");
1327     return CXChildVisit_Recurse;
1328   }
1329 
1330   return CXChildVisit_Continue;
1331 }
.fi
.SS "void free_remapped_files (struct CXUnsavedFile * unsaved_files, int num_unsaved_files)"

.PP
Definition at line 206 of file c\-index\-test\&.c\&.
.PP
.nf
207                                                 {
208   int i;
209   for (i = 0; i != num_unsaved_files; ++i) {
210     free((char *)unsaved_files[i]\&.Filename);
211     free((char *)unsaved_files[i]\&.Contents);
212   }
213   free(unsaved_files);
214 }
.fi
.SS "void InclusionVisitor (CXFile includedFile, CXSourceLocation * includeStack, unsigned includeStackLen, CXClientData data)"

.PP
Definition at line 1418 of file c\-index\-test\&.c\&.
.PP
.nf
1419                                                                    {
1420 
1421   unsigned i;
1422   CXString fname;
1423 
1424   fname = clang_getFileName(includedFile);
1425   printf("file: %s\nincluded by:\n", clang_getCString(fname));
1426   clang_disposeString(fname);
1427 
1428   for (i = 0; i < includeStackLen; ++i) {
1429     CXFile includingFile;
1430     unsigned line, column;
1431     clang_getSpellingLocation(includeStack[i], &includingFile, &line,
1432                               &column, 0);
1433     fname = clang_getFileName(includingFile);
1434     printf("  %s:%d:%d\n", clang_getCString(fname), line, column);
1435     clang_disposeString(fname);
1436   }
1437   printf("\n");
1438 }
.fi
.PP
References clang_disposeString(), clang_getCString(), clang_getFileName(), and clang_getSpellingLocation()\&.
.PP
Referenced by PrintInclusionStack()\&.
.SS "int indextest_core_main (int argc, const char ** argv)"

.PP
Definition at line 330 of file core_main\&.cpp\&.
.PP
.nf
330                                                      {
331   sys::PrintStackTraceOnErrorSignal(argv[0]);
332   PrettyStackTraceProgram X(argc, argv);
333   void *MainAddr = (void*) (intptr_t) indextest_core_main;
334   std::string Executable = llvm::sys::fs::getMainExecutable(argv[0], MainAddr);
335 
336   assert(argv[1] == StringRef("core"));
337   ++argv;
338   --argc;
339 
340   std::vector<const char *> CompArgs;
341   const char **DoubleDash = std::find(argv, argv + argc, StringRef("--"));
342   if (DoubleDash != argv + argc) {
343     CompArgs = std::vector<const char *>(DoubleDash + 1, argv + argc);
344     argc = DoubleDash - argv;
345   }
346 
347   cl::HideUnrelatedOptions(options::IndexTestCoreCategory);
348   cl::ParseCommandLineOptions(argc, argv, "index-test-core");
349 
350   if (options::Action == ActionType::None) {
351     errs() << "error: action required; pass '-help' for options\n";
352     return 1;
353   }
354 
355   if (options::Action == ActionType::PrintSourceSymbols) {
356     if (!options::ModuleFilePath\&.empty()) {
357       return printSourceSymbolsFromModule(options::ModuleFilePath,
358                                           options::ModuleFormat);
359     }
360     if (CompArgs\&.empty()) {
361       errs() << "error: missing compiler args; pass '-- <compiler arguments>'\n";
362       return 1;
363     }
364     return printSourceSymbols(Executable\&.c_str(), CompArgs,
365                               options::DumpModuleImports,
366                               options::IncludeLocals, options::IgnoreMacros);
367   }
368 
369   return 0;
370 }
.fi
.PP
References indextest_core_main()\&.
.PP
Referenced by indextest_core_main()\&.
.SS "int indextest_perform_shell_execution (const char * command_line)"

.PP
Definition at line 376 of file core_main\&.cpp\&.
.PP
.nf
376                                                                 {
377   BumpPtrAllocator Alloc;
378   llvm::StringSaver Saver(Alloc);
379   SmallVector<const char *, 4> Args;
380   llvm::cl::TokenizeGNUCommandLine(command_line, Saver, Args);
381   auto Program = llvm::sys::findProgramByName(Args[0]);
382   if (std::error_code ec = Program\&.getError()) {
383     llvm::errs() << "command not found: " << Args[0] << "\n";
384     return ec\&.value();
385   }
386   SmallVector<StringRef, 8> execArgs(Args\&.begin(), Args\&.end());
387   return llvm::sys::ExecuteAndWait(*Program, execArgs);
388 }
.fi
.SS "int main (int argc, const char ** argv)"

.PP
Definition at line 5002 of file c\-index\-test\&.c\&.
.PP
.nf
5002                                       {
5003   thread_info client_data;
5004 
5005   atexit(flush_atexit);
5006 
5007 #ifdef CLANG_HAVE_LIBXML
5008   LIBXML_TEST_VERSION
5009 #endif
5010 
5011   if (argc > 1 && strcmp(argv[1], "core") == 0)
5012     return indextest_core_main(argc, argv);
5013 
5014   client_data\&.main_func = cindextest_main;
5015   client_data\&.argc = argc;
5016   client_data\&.argv = argv;
5017 
5018   if (getenv("CINDEXTEST_NOTHREADS"))
5019     return client_data\&.main_func(client_data\&.argc, client_data\&.argv);
5020 
5021   clang_executeOnThread(thread_runner, &client_data, 0);
5022   return client_data\&.result;
5023 }
.fi
.SS "int parse_file_line_column (const char * input, char ** filename, unsigned * line, unsigned * column, unsigned * second_line, unsigned * second_column)"

.PP
Definition at line 2331 of file c\-index\-test\&.c\&.
.PP
.nf
2333                                                     {
2334   /* Find the second colon\&. */
2335   const char *last_colon = strrchr(input, ':');
2336   unsigned values[4], i;
2337   unsigned num_values = (second_line && second_column)? 4 : 2;
2338 
2339   char *endptr = 0;
2340   if (!last_colon || last_colon == input) {
2341     if (num_values == 4)
2342       fprintf(stderr, "could not parse filename:line:column:line:column in "
2343               "'%s'\n", input);
2344     else
2345       fprintf(stderr, "could not parse filename:line:column in '%s'\n", input);
2346     return 1;
2347   }
2348 
2349   for (i = 0; i != num_values; ++i) {
2350     const char *prev_colon;
2351 
2352     /* Parse the next line or column\&. */
2353     values[num_values - i - 1] = strtol(last_colon + 1, &endptr, 10);
2354     if (*endptr != 0 && *endptr != ':') {
2355       fprintf(stderr, "could not parse %s in '%s'\n",
2356               (i % 2 ? "column" : "line"), input);
2357       return 1;
2358     }
2359 
2360     if (i + 1 == num_values)
2361       break;
2362 
2363     /* Find the previous colon\&. */
2364     prev_colon = last_colon - 1;
2365     while (prev_colon != input && *prev_colon != ':')
2366       --prev_colon;
2367     if (prev_colon == input) {
2368       fprintf(stderr, "could not parse %s in '%s'\n",
2369               (i % 2 == 0? "column" : "line"), input);
2370       return 1;
2371     }
2372 
2373     last_colon = prev_colon;
2374   }
2375 
2376   *line = values[0];
2377   *column = values[1];
2378 
2379   if (second_line && second_column) {
2380     *second_line = values[2];
2381     *second_column = values[3];
2382   }
2383 
2384   /* Copy the file name\&. */
2385   *filename = (char*)malloc(last_colon - input + 1);
2386   assert(*filename);
2387   memcpy(*filename, input, last_colon - input);
2388   (*filename)[last_colon - input] = 0;
2389   return 0;
2390 }
.fi
.PP
Referenced by perform_code_completion(), and perform_token_annotation()\&.
.SS "int perform_code_completion (int argc, const char ** argv, int timing_only)"

.PP
Definition at line 2665 of file c\-index\-test\&.c\&.
.PP
.nf
2665                                                                           {
2666   const char *input = argv[1];
2667   char *filename = 0;
2668   unsigned line;
2669   unsigned column;
2670   CXIndex CIdx;
2671   int errorCode;
2672   struct CXUnsavedFile *unsaved_files = 0;
2673   int num_unsaved_files = 0;
2674   CXCodeCompleteResults *results = 0;
2675   enum CXErrorCode Err;
2676   CXTranslationUnit TU;
2677   unsigned I, Repeats = 1;
2678   unsigned completionOptions = clang_defaultCodeCompleteOptions();
2679   const char *InvocationPath;
2680 
2681   if (getenv("CINDEXTEST_CODE_COMPLETE_PATTERNS"))
2682     completionOptions |= CXCodeComplete_IncludeCodePatterns;
2683   if (getenv("CINDEXTEST_COMPLETION_BRIEF_COMMENTS"))
2684     completionOptions |= CXCodeComplete_IncludeBriefComments;
2685   if (getenv("CINDEXTEST_COMPLETION_SKIP_PREAMBLE"))
2686     completionOptions |= CXCodeComplete_SkipPreamble;
2687   if (getenv("CINDEXTEST_COMPLETION_INCLUDE_FIXITS"))
2688     completionOptions |= CXCodeComplete_IncludeCompletionsWithFixIts;
2689   
2690   if (timing_only)
2691     input += strlen("-code-completion-timing=");
2692   else
2693     input += strlen("-code-completion-at=");
2694 
2695   if ((errorCode = parse_file_line_column(input, &filename, &line, &column,
2696                                           0, 0)))
2697     return errorCode;
2698 
2699   if (parse_remapped_files(argc, argv, 2, &unsaved_files, &num_unsaved_files))
2700     return -1;
2701 
2702   CIdx = clang_createIndex(0, 0);
2703   InvocationPath = getenv("CINDEXTEST_INVOCATION_EMISSION_PATH");
2704   if (InvocationPath)
2705     clang_CXIndex_setInvocationEmissionPathOption(CIdx, InvocationPath);
2706 
2707   if (getenv("CINDEXTEST_EDITING"))
2708     Repeats = 5;
2709 
2710   Err = clang_parseTranslationUnit2(CIdx, 0,
2711                                     argv + num_unsaved_files + 2,
2712                                     argc - num_unsaved_files - 2,
2713                                     0, 0, getDefaultParsingOptions(), &TU);
2714   if (Err != CXError_Success) {
2715     fprintf(stderr, "Unable to load translation unit!\n");
2716     describeLibclangFailure(Err);
2717     return 1;
2718   }
2719 
2720   Err = clang_reparseTranslationUnit(TU, 0, 0,
2721                                      clang_defaultReparseOptions(TU));
2722 
2723   if (Err != CXError_Success) {
2724     fprintf(stderr, "Unable to reparse translation unit!\n");
2725     describeLibclangFailure(Err);
2726     clang_disposeTranslationUnit(TU);
2727     return 1;
2728   }
2729 
2730   for (I = 0; I != Repeats; ++I) {
2731     results = clang_codeCompleteAt(TU, filename, line, column,
2732                                    unsaved_files, num_unsaved_files,
2733                                    completionOptions);
2734     if (!results) {
2735       fprintf(stderr, "Unable to perform code completion!\n");
2736       return 1;
2737     }
2738     if (I != Repeats-1)
2739       clang_disposeCodeCompleteResults(results);
2740   }
2741 
2742   if (results) {
2743     unsigned i, n = results->NumResults, containerIsIncomplete = 0;
2744     unsigned long long contexts;
2745     enum CXCursorKind containerKind;
2746     CXString objCSelector;
2747     const char *selectorString;
2748     if (!timing_only) {      
2749       /* Sort the code-completion results based on the typed text\&. */
2750       clang_sortCodeCompletionResults(results->Results, results->NumResults);
2751 
2752       for (i = 0; i != n; ++i)
2753         print_completion_result(TU, results, i, stdout);
2754     }
2755     n = clang_codeCompleteGetNumDiagnostics(results);
2756     for (i = 0; i != n; ++i) {
2757       CXDiagnostic diag = clang_codeCompleteGetDiagnostic(results, i);
2758       PrintDiagnostic(diag);
2759       clang_disposeDiagnostic(diag);
2760     }
2761     
2762     contexts = clang_codeCompleteGetContexts(results);
2763     print_completion_contexts(contexts, stdout);
2764     
2765     containerKind = clang_codeCompleteGetContainerKind(results,
2766                                                        &containerIsIncomplete);
2767     
2768     if (containerKind != CXCursor_InvalidCode) {
2769       /* We have found a container */
2770       CXString containerUSR, containerKindSpelling;
2771       containerKindSpelling = clang_getCursorKindSpelling(containerKind);
2772       printf("Container Kind: %s\n", clang_getCString(containerKindSpelling));
2773       clang_disposeString(containerKindSpelling);
2774       
2775       if (containerIsIncomplete) {
2776         printf("Container is incomplete\n");
2777       }
2778       else {
2779         printf("Container is complete\n");
2780       }
2781       
2782       containerUSR = clang_codeCompleteGetContainerUSR(results);
2783       printf("Container USR: %s\n", clang_getCString(containerUSR));
2784       clang_disposeString(containerUSR);
2785     }
2786     
2787     objCSelector = clang_codeCompleteGetObjCSelector(results);
2788     selectorString = clang_getCString(objCSelector);
2789     if (selectorString && strlen(selectorString) > 0) {
2790       printf("Objective-C selector: %s\n", selectorString);
2791     }
2792     clang_disposeString(objCSelector);
2793     
2794     clang_disposeCodeCompleteResults(results);
2795   }
2796   clang_disposeTranslationUnit(TU);
2797   clang_disposeIndex(CIdx);
2798   free(filename);
2799 
2800   free_remapped_files(unsaved_files, num_unsaved_files);
2801 
2802   return 0;
2803 }
.fi
.PP
References clang_defaultCodeCompleteOptions(), and parse_file_line_column()\&.
.SS "int perform_test_load_source (int argc, const char ** argv, const char * filter, CXCursorVisitor Visitor, \fBPostVisitTU\fP PV)"

.PP
Definition at line 2012 of file c\-index\-test\&.c\&.
.PP
.nf
2014                                              {
2015   CXIndex Idx;
2016   CXTranslationUnit TU;
2017   const char *CommentSchemaFile;
2018   struct CXUnsavedFile *unsaved_files = 0;
2019   int num_unsaved_files = 0;
2020   enum CXErrorCode Err;
2021   int result;
2022   unsigned Repeats = 0;
2023   unsigned I;
2024   const char *InvocationPath;
2025 
2026   Idx = clang_createIndex(/* excludeDeclsFromPCH */
2027                           (!strcmp(filter, "local") ||
2028                            !strcmp(filter, "local-display") ||
2029                            !strcmp(filter, "local-pretty"))
2030                               ? 1
2031                               : 0,
2032                           /* displayDiagnostics=*/1);
2033   InvocationPath = getenv("CINDEXTEST_INVOCATION_EMISSION_PATH");
2034   if (InvocationPath)
2035     clang_CXIndex_setInvocationEmissionPathOption(Idx, InvocationPath);
2036 
2037   if ((CommentSchemaFile = parse_comments_schema(argc, argv))) {
2038     argc--;
2039     argv++;
2040   }
2041 
2042   if (parse_remapped_files(argc, argv, 0, &unsaved_files, &num_unsaved_files)) {
2043     clang_disposeIndex(Idx);
2044     return -1;
2045   }
2046 
2047   if (getenv("CINDEXTEST_EDITING"))
2048     Repeats = 5;
2049 
2050   Err = clang_parseTranslationUnit2(Idx, 0,
2051                                     argv + num_unsaved_files,
2052                                     argc - num_unsaved_files,
2053                                     unsaved_files, num_unsaved_files,
2054                                     getDefaultParsingOptions(), &TU);
2055   if (Err != CXError_Success) {
2056     fprintf(stderr, "Unable to load translation unit!\n");
2057     describeLibclangFailure(Err);
2058     free_remapped_files(unsaved_files, num_unsaved_files);
2059     clang_disposeIndex(Idx);
2060     return 1;
2061   }
2062 
2063   for (I = 0; I != Repeats; ++I) {
2064     if (checkForErrors(TU) != 0)
2065       return -1;
2066 
2067     if (Repeats > 1) {
2068       clang_suspendTranslationUnit(TU);
2069 
2070       Err = clang_reparseTranslationUnit(TU, num_unsaved_files, unsaved_files,
2071                                          clang_defaultReparseOptions(TU));
2072       if (Err != CXError_Success) {
2073         describeLibclangFailure(Err);
2074         free_remapped_files(unsaved_files, num_unsaved_files);
2075         clang_disposeIndex(Idx);
2076         return 1;
2077       }
2078     }
2079   }
2080 
2081   result = perform_test_load(Idx, TU, filter, NULL, Visitor, PV,
2082                              CommentSchemaFile);
2083   free_remapped_files(unsaved_files, num_unsaved_files);
2084   clang_disposeIndex(Idx);
2085   return result;
2086 }
.fi
.PP
References clang_createIndex(), and clang_CXIndex_setInvocationEmissionPathOption()\&.
.SS "int perform_test_load_tu (const char * file, const char * filter, const char * prefix, CXCursorVisitor Visitor, \fBPostVisitTU\fP PV)"

.PP
Definition at line 1992 of file c\-index\-test\&.c\&.
.PP
.nf
1994                                          {
1995   CXIndex Idx;
1996   CXTranslationUnit TU;
1997   int result;
1998   Idx = clang_createIndex(/* excludeDeclsFromPCH */
1999                           !strcmp(filter, "local") ? 1 : 0,
2000                           /* displayDiagnostics=*/1);
2001 
2002   if (!CreateTranslationUnit(Idx, file, &TU)) {
2003     clang_disposeIndex(Idx);
2004     return 1;
2005   }
2006 
2007   result = perform_test_load(Idx, TU, filter, prefix, Visitor, PV, NULL);
2008   clang_disposeIndex(Idx);
2009   return result;
2010 }
.fi
.PP
References clang_createIndex()\&.
.SS "int perform_test_reparse_source (int argc, const char ** argv, int trials, const char * filter, CXCursorVisitor Visitor, \fBPostVisitTU\fP PV)"

.PP
Definition at line 2088 of file c\-index\-test\&.c\&.
.PP
.nf
2090                                                 {
2091   CXIndex Idx;
2092   CXTranslationUnit TU;
2093   struct CXUnsavedFile *unsaved_files = 0;
2094   int num_unsaved_files = 0;
2095   int compiler_arg_idx = 0;
2096   enum CXErrorCode Err;
2097   int result, i;
2098   int trial;
2099   int execute_after_trial = 0;
2100   const char *execute_command = NULL;
2101   int remap_after_trial = 0;
2102   char *endptr = 0;
2103   
2104   Idx = clang_createIndex(/* excludeDeclsFromPCH */
2105                           !strcmp(filter, "local") ? 1 : 0,
2106                           /* displayDiagnostics=*/1);
2107   
2108   if (parse_remapped_files(argc, argv, 0, &unsaved_files, &num_unsaved_files)) {
2109     clang_disposeIndex(Idx);
2110     return -1;
2111   }
2112 
2113   for (i = 0; i < argc; ++i) {
2114     if (strcmp(argv[i], "--") == 0)
2115       break;
2116   }
2117   if (i < argc)
2118     compiler_arg_idx = i+1;
2119   if (num_unsaved_files > compiler_arg_idx)
2120     compiler_arg_idx = num_unsaved_files;
2121   
2122   /* Load the initial translation unit -- we do this without honoring remapped
2123    * files, so that we have a way to test results after changing the source\&. */
2124   Err = clang_parseTranslationUnit2(Idx, 0,
2125                                     argv + compiler_arg_idx,
2126                                     argc - compiler_arg_idx,
2127                                     0, 0, getDefaultParsingOptions(), &TU);
2128   if (Err != CXError_Success) {
2129     fprintf(stderr, "Unable to load translation unit!\n");
2130     describeLibclangFailure(Err);
2131     free_remapped_files(unsaved_files, num_unsaved_files);
2132     clang_disposeIndex(Idx);
2133     return 1;
2134   }
2135   
2136   if (checkForErrors(TU) != 0)
2137     return -1;
2138 
2139   if (getenv("CINDEXTEST_EXECUTE_COMMAND")) {
2140     execute_command = getenv("CINDEXTEST_EXECUTE_COMMAND");
2141   }
2142   if (getenv("CINDEXTEST_EXECUTE_AFTER_TRIAL")) {
2143     execute_after_trial =
2144         strtol(getenv("CINDEXTEST_EXECUTE_AFTER_TRIAL"), &endptr, 10);
2145   }
2146 
2147   if (getenv("CINDEXTEST_REMAP_AFTER_TRIAL")) {
2148     remap_after_trial =
2149         strtol(getenv("CINDEXTEST_REMAP_AFTER_TRIAL"), &endptr, 10);
2150   }
2151 
2152   for (trial = 0; trial < trials; ++trial) {
2153     if (execute_command && trial == execute_after_trial) {
2154       result = indextest_perform_shell_execution(execute_command);
2155       if (result != 0)
2156         return result;
2157     }
2158 
2159     free_remapped_files(unsaved_files, num_unsaved_files);
2160     if (parse_remapped_files_with_try(trial, argc, argv, 0,
2161                                       &unsaved_files, &num_unsaved_files)) {
2162       clang_disposeTranslationUnit(TU);
2163       clang_disposeIndex(Idx);
2164       return -1;
2165     }
2166 
2167     Err = clang_reparseTranslationUnit(
2168         TU,
2169         trial >= remap_after_trial ? num_unsaved_files : 0,
2170         trial >= remap_after_trial ? unsaved_files : 0,
2171         clang_defaultReparseOptions(TU));
2172     if (Err != CXError_Success) {
2173       fprintf(stderr, "Unable to reparse translation unit!\n");
2174       describeLibclangFailure(Err);
2175       clang_disposeTranslationUnit(TU);
2176       free_remapped_files(unsaved_files, num_unsaved_files);
2177       clang_disposeIndex(Idx);
2178       return -1;      
2179     }
2180 
2181     if (checkForErrors(TU) != 0)
2182       return -1;
2183   }
2184   
2185   result = perform_test_load(Idx, TU, filter, NULL, Visitor, PV, NULL);
2186 
2187   free_remapped_files(unsaved_files, num_unsaved_files);
2188   clang_disposeIndex(Idx);
2189   return result;
2190 }
.fi
.PP
References clang_createIndex()\&.
.SS "int perform_token_annotation (int argc, const char ** argv)"

.PP
Definition at line 4141 of file c\-index\-test\&.c\&.
.PP
.nf
4141                                                           {
4142   const char *input = argv[1];
4143   char *filename = 0;
4144   unsigned line, second_line;
4145   unsigned column, second_column;
4146   CXIndex CIdx;
4147   CXTranslationUnit TU = 0;
4148   int errorCode;
4149   struct CXUnsavedFile *unsaved_files = 0;
4150   int num_unsaved_files = 0;
4151   CXToken *tokens;
4152   unsigned num_tokens;
4153   CXSourceRange range;
4154   CXSourceLocation startLoc, endLoc;
4155   CXFile file = 0;
4156   CXCursor *cursors = 0;
4157   CXSourceRangeList *skipped_ranges = 0;
4158   enum CXErrorCode Err;
4159   unsigned i;
4160 
4161   input += strlen("-test-annotate-tokens=");
4162   if ((errorCode = parse_file_line_column(input, &filename, &line, &column,
4163                                           &second_line, &second_column)))
4164     return errorCode;
4165 
4166   if (parse_remapped_files(argc, argv, 2, &unsaved_files, &num_unsaved_files)) {
4167     free(filename);
4168     return -1;
4169   }
4170 
4171   CIdx = clang_createIndex(0, 1);
4172   Err = clang_parseTranslationUnit2(CIdx, argv[argc - 1],
4173                                     argv + num_unsaved_files + 2,
4174                                     argc - num_unsaved_files - 3,
4175                                     unsaved_files,
4176                                     num_unsaved_files,
4177                                     getDefaultParsingOptions(), &TU);
4178   if (Err != CXError_Success) {
4179     fprintf(stderr, "unable to parse input\n");
4180     describeLibclangFailure(Err);
4181     clang_disposeIndex(CIdx);
4182     free(filename);
4183     free_remapped_files(unsaved_files, num_unsaved_files);
4184     return -1;
4185   }
4186   errorCode = 0;
4187 
4188   if (checkForErrors(TU) != 0) {
4189     errorCode = -1;
4190     goto teardown;
4191   }
4192 
4193   if (getenv("CINDEXTEST_EDITING")) {
4194     for (i = 0; i < 5; ++i) {
4195       Err = clang_reparseTranslationUnit(TU, num_unsaved_files, unsaved_files,
4196                                          clang_defaultReparseOptions(TU));
4197       if (Err != CXError_Success) {
4198         fprintf(stderr, "Unable to reparse translation unit!\n");
4199         describeLibclangFailure(Err);
4200         errorCode = -1;
4201         goto teardown;
4202       }
4203     }
4204   }
4205 
4206   if (checkForErrors(TU) != 0) {
4207     errorCode = -1;
4208     goto teardown;
4209   }
4210 
4211   file = clang_getFile(TU, filename);
4212   if (!file) {
4213     fprintf(stderr, "file %s is not in this translation unit\n", filename);
4214     errorCode = -1;
4215     goto teardown;
4216   }
4217 
4218   startLoc = clang_getLocation(TU, file, line, column);
4219   if (clang_equalLocations(clang_getNullLocation(), startLoc)) {
4220     fprintf(stderr, "invalid source location %s:%d:%d\n", filename, line,
4221             column);
4222     errorCode = -1;
4223     goto teardown;
4224   }
4225 
4226   endLoc = clang_getLocation(TU, file, second_line, second_column);
4227   if (clang_equalLocations(clang_getNullLocation(), endLoc)) {
4228     fprintf(stderr, "invalid source location %s:%d:%d\n", filename,
4229             second_line, second_column);
4230     errorCode = -1;
4231     goto teardown;
4232   }
4233 
4234   range = clang_getRange(startLoc, endLoc);
4235   clang_tokenize(TU, range, &tokens, &num_tokens);
4236 
4237   if (checkForErrors(TU) != 0) {
4238     errorCode = -1;
4239     goto teardown;
4240   }
4241 
4242   cursors = (CXCursor *)malloc(num_tokens * sizeof(CXCursor));
4243   assert(cursors);
4244   clang_annotateTokens(TU, tokens, num_tokens, cursors);
4245 
4246   if (checkForErrors(TU) != 0) {
4247     errorCode = -1;
4248     goto teardown;
4249   }
4250 
4251   skipped_ranges = clang_getSkippedRanges(TU, file);
4252   for (i = 0; i != skipped_ranges->count; ++i) {
4253     unsigned start_line, start_column, end_line, end_column;
4254     clang_getSpellingLocation(clang_getRangeStart(skipped_ranges->ranges[i]),
4255                               0, &start_line, &start_column, 0);
4256     clang_getSpellingLocation(clang_getRangeEnd(skipped_ranges->ranges[i]),
4257                               0, &end_line, &end_column, 0);
4258     printf("Skipping: ");
4259     PrintExtent(stdout, start_line, start_column, end_line, end_column);
4260     printf("\n");
4261   }
4262   clang_disposeSourceRangeList(skipped_ranges);
4263 
4264   for (i = 0; i != num_tokens; ++i) {
4265     const char *kind = "<unknown>";
4266     CXString spelling = clang_getTokenSpelling(TU, tokens[i]);
4267     CXSourceRange extent = clang_getTokenExtent(TU, tokens[i]);
4268     unsigned start_line, start_column, end_line, end_column;
4269 
4270     switch (clang_getTokenKind(tokens[i])) {
4271     case CXToken_Punctuation: kind = "Punctuation"; break;
4272     case CXToken_Keyword: kind = "Keyword"; break;
4273     case CXToken_Identifier: kind = "Identifier"; break;
4274     case CXToken_Literal: kind = "Literal"; break;
4275     case CXToken_Comment: kind = "Comment"; break;
4276     }
4277     clang_getSpellingLocation(clang_getRangeStart(extent),
4278                               0, &start_line, &start_column, 0);
4279     clang_getSpellingLocation(clang_getRangeEnd(extent),
4280                               0, &end_line, &end_column, 0);
4281     printf("%s: \"%s\" ", kind, clang_getCString(spelling));
4282     clang_disposeString(spelling);
4283     PrintExtent(stdout, start_line, start_column, end_line, end_column);
4284     if (!clang_isInvalid(cursors[i]\&.kind)) {
4285       printf(" ");
4286       PrintCursor(cursors[i], NULL);
4287     }
4288     printf("\n");
4289   }
4290   free(cursors);
4291   clang_disposeTokens(TU, tokens, num_tokens);
4292 
4293  teardown:
4294   PrintDiagnostics(TU);
4295   clang_disposeTranslationUnit(TU);
4296   clang_disposeIndex(CIdx);
4297   free(filename);
4298   free_remapped_files(unsaved_files, num_unsaved_files);
4299   return errorCode;
4300 }
.fi
.PP
References parse_file_line_column()\&.
.SS "void print_completion_contexts (unsigned long long contexts, FILE * file)"

.PP
Definition at line 2592 of file c\-index\-test\&.c\&.
.PP
.nf
2592                                                                         {
2593   fprintf(file, "Completion contexts:\n");
2594   if (contexts == CXCompletionContext_Unknown) {
2595     fprintf(file, "Unknown\n");
2596   }
2597   if (contexts & CXCompletionContext_AnyType) {
2598     fprintf(file, "Any type\n");
2599   }
2600   if (contexts & CXCompletionContext_AnyValue) {
2601     fprintf(file, "Any value\n");
2602   }
2603   if (contexts & CXCompletionContext_ObjCObjectValue) {
2604     fprintf(file, "Objective-C object value\n");
2605   }
2606   if (contexts & CXCompletionContext_ObjCSelectorValue) {
2607     fprintf(file, "Objective-C selector value\n");
2608   }
2609   if (contexts & CXCompletionContext_CXXClassTypeValue) {
2610     fprintf(file, "C++ class type value\n");
2611   }
2612   if (contexts & CXCompletionContext_DotMemberAccess) {
2613     fprintf(file, "Dot member access\n");
2614   }
2615   if (contexts & CXCompletionContext_ArrowMemberAccess) {
2616     fprintf(file, "Arrow member access\n");
2617   }
2618   if (contexts & CXCompletionContext_ObjCPropertyAccess) {
2619     fprintf(file, "Objective-C property access\n");
2620   }
2621   if (contexts & CXCompletionContext_EnumTag) {
2622     fprintf(file, "Enum tag\n");
2623   }
2624   if (contexts & CXCompletionContext_UnionTag) {
2625     fprintf(file, "Union tag\n");
2626   }
2627   if (contexts & CXCompletionContext_StructTag) {
2628     fprintf(file, "Struct tag\n");
2629   }
2630   if (contexts & CXCompletionContext_ClassTag) {
2631     fprintf(file, "Class name\n");
2632   }
2633   if (contexts & CXCompletionContext_Namespace) {
2634     fprintf(file, "Namespace or namespace alias\n");
2635   }
2636   if (contexts & CXCompletionContext_NestedNameSpecifier) {
2637     fprintf(file, "Nested name specifier\n");
2638   }
2639   if (contexts & CXCompletionContext_ObjCInterface) {
2640     fprintf(file, "Objective-C interface\n");
2641   }
2642   if (contexts & CXCompletionContext_ObjCProtocol) {
2643     fprintf(file, "Objective-C protocol\n");
2644   }
2645   if (contexts & CXCompletionContext_ObjCCategory) {
2646     fprintf(file, "Objective-C category\n");
2647   }
2648   if (contexts & CXCompletionContext_ObjCInstanceMessage) {
2649     fprintf(file, "Objective-C instance method\n");
2650   }
2651   if (contexts & CXCompletionContext_ObjCClassMessage) {
2652     fprintf(file, "Objective-C class method\n");
2653   }
2654   if (contexts & CXCompletionContext_ObjCSelectorName) {
2655     fprintf(file, "Objective-C selector name\n");
2656   }
2657   if (contexts & CXCompletionContext_MacroName) {
2658     fprintf(file, "Macro name\n");
2659   }
2660   if (contexts & CXCompletionContext_NaturalLanguage) {
2661     fprintf(file, "Natural language\n");
2662   }
2663 }
.fi
.SS "int print_usrs (const char ** I, const char ** E)"

.PP
Definition at line 4421 of file c\-index\-test\&.c\&.
.PP
.nf
4421                                                {
4422   while (I != E) {
4423     const char *kind = *I;
4424     unsigned len = strlen(kind);
4425     switch (len) {
4426       case 8:
4427         if (memcmp(kind, "ObjCIvar", 8) == 0) {
4428           if (I + 2 >= E)
4429             return insufficient_usr(kind, "<ivar name> <class USR>");
4430           if (!isUSR(I[2]))
4431             return not_usr("<class USR>", I[2]);
4432           else {
4433             CXString x = createCXString(I[2]);
4434             print_usr(clang_constructUSR_ObjCIvar(I[1], x));
4435           }
4436 
4437           I += 3;
4438           continue;
4439         }
4440         break;
4441       case 9:
4442         if (memcmp(kind, "ObjCClass", 9) == 0) {
4443           if (I + 1 >= E)
4444             return insufficient_usr(kind, "<class name>");
4445           print_usr(clang_constructUSR_ObjCClass(I[1]));
4446           I += 2;
4447           continue;
4448         }
4449         break;
4450       case 10:
4451         if (memcmp(kind, "ObjCMethod", 10) == 0) {
4452           if (I + 3 >= E)
4453             return insufficient_usr(kind, "<method selector> "
4454                 "[0=class method|1=instance method] <class USR>");
4455           if (!isUSR(I[3]))
4456             return not_usr("<class USR>", I[3]);
4457           else {
4458             CXString x = createCXString(I[3]);
4459             print_usr(clang_constructUSR_ObjCMethod(I[1], atoi(I[2]), x));
4460           }
4461           I += 4;
4462           continue;
4463         }
4464         break;
4465       case 12:
4466         if (memcmp(kind, "ObjCCategory", 12) == 0) {
4467           if (I + 2 >= E)
4468             return insufficient_usr(kind, "<class name> <category name>");
4469           print_usr(clang_constructUSR_ObjCCategory(I[1], I[2]));
4470           I += 3;
4471           continue;
4472         }
4473         if (memcmp(kind, "ObjCProtocol", 12) == 0) {
4474           if (I + 1 >= E)
4475             return insufficient_usr(kind, "<protocol name>");
4476           print_usr(clang_constructUSR_ObjCProtocol(I[1]));
4477           I += 2;
4478           continue;
4479         }
4480         if (memcmp(kind, "ObjCProperty", 12) == 0) {
4481           if (I + 2 >= E)
4482             return insufficient_usr(kind, "<property name> <class USR>");
4483           if (!isUSR(I[2]))
4484             return not_usr("<class USR>", I[2]);
4485           else {
4486             CXString x = createCXString(I[2]);
4487             print_usr(clang_constructUSR_ObjCProperty(I[1], x));
4488           }
4489           I += 3;
4490           continue;
4491         }
4492         break;
4493       default:
4494         break;
4495     }
4496     break;
4497   }
4498 
4499   if (I != E) {
4500     fprintf(stderr, "Invalid USR kind: %s\n", *I);
4501     display_usrs();
4502     return 1;
4503   }
4504   return 0;
4505 }
.fi
.PP
Referenced by print_usrs_file()\&.
.SS "int print_usrs_file (const char * file_name)"

.PP
Definition at line 4507 of file c\-index\-test\&.c\&.
.PP
.nf
4507                                            {
4508   char line[2048];
4509   const char *args[128];
4510   unsigned numChars = 0;
4511 
4512   FILE *fp = fopen(file_name, "r");
4513   if (!fp) {
4514     fprintf(stderr, "error: cannot open '%s'\n", file_name);
4515     return 1;
4516   }
4517 
4518   /* This code is not really all that safe, but it works fine for testing\&. */
4519   while (!feof(fp)) {
4520     char c = fgetc(fp);
4521     if (c == '\n') {
4522       unsigned i = 0;
4523       const char *s = 0;
4524 
4525       if (numChars == 0)
4526         continue;
4527 
4528       line[numChars] = '\0';
4529       numChars = 0;
4530 
4531       if (line[0] == '/' && line[1] == '/')
4532         continue;
4533 
4534       s = strtok(line, " ");
4535       while (s) {
4536         args[i] = s;
4537         ++i;
4538         s = strtok(0, " ");
4539       }
4540       if (print_usrs(&args[0], &args[i]))
4541         return 1;
4542     }
4543     else
4544       line[numChars++] = c;
4545   }
4546 
4547   fclose(fp);
4548   return 0;
4549 }
.fi
.PP
References print_usrs()\&.
.SS "void PrintDiagnostic (CXDiagnostic Diagnostic)"

.PP
Definition at line 1189 of file c\-index\-test\&.c\&.
.PP
.nf
1189                                               {
1190   FILE *out = stderr;
1191   CXFile file;
1192   CXString Msg;
1193   unsigned display_opts = CXDiagnostic_DisplaySourceLocation
1194     | CXDiagnostic_DisplayColumn | CXDiagnostic_DisplaySourceRanges
1195     | CXDiagnostic_DisplayOption;
1196   unsigned i, num_fixits;
1197 
1198   if (clang_getDiagnosticSeverity(Diagnostic) == CXDiagnostic_Ignored)
1199     return;
1200 
1201   Msg = clang_formatDiagnostic(Diagnostic, display_opts);
1202   fprintf(stderr, "%s\n", clang_getCString(Msg));
1203   clang_disposeString(Msg);
1204 
1205   clang_getSpellingLocation(clang_getDiagnosticLocation(Diagnostic),
1206                             &file, 0, 0, 0);
1207   if (!file)
1208     return;
1209 
1210   num_fixits = clang_getDiagnosticNumFixIts(Diagnostic);
1211   fprintf(stderr, "Number FIX-ITs = %d\n", num_fixits);
1212   for (i = 0; i != num_fixits; ++i) {
1213     CXSourceRange range;
1214     CXString insertion_text = clang_getDiagnosticFixIt(Diagnostic, i, &range);
1215     CXSourceLocation start = clang_getRangeStart(range);
1216     CXSourceLocation end = clang_getRangeEnd(range);
1217     unsigned start_line, start_column, end_line, end_column;
1218     CXFile start_file, end_file;
1219     clang_getSpellingLocation(start, &start_file, &start_line,
1220                               &start_column, 0);
1221     clang_getSpellingLocation(end, &end_file, &end_line, &end_column, 0);
1222     if (clang_equalLocations(start, end)) {
1223       /* Insertion\&. */
1224       if (start_file == file)
1225         fprintf(out, "FIX-IT: Insert \"%s\" at %d:%d\n",
1226                 clang_getCString(insertion_text), start_line, start_column);
1227     } else if (strcmp(clang_getCString(insertion_text), "") == 0) {
1228       /* Removal\&. */
1229       if (start_file == file && end_file == file) {
1230         fprintf(out, "FIX-IT: Remove ");
1231         PrintExtent(out, start_line, start_column, end_line, end_column);
1232         fprintf(out, "\n");
1233       }
1234     } else {
1235       /* Replacement\&. */
1236       if (start_file == end_file) {
1237         fprintf(out, "FIX-IT: Replace ");
1238         PrintExtent(out, start_line, start_column, end_line, end_column);
1239         fprintf(out, " with \"%s\"\n", clang_getCString(insertion_text));
1240       }
1241     }
1242     clang_disposeString(insertion_text);
1243   }
1244 }
.fi
.PP
References clang_disposeString(), clang_equalLocations(), clang_formatDiagnostic(), clang_getCString(), clang_getDiagnosticFixIt(), clang_getDiagnosticLocation(), clang_getDiagnosticNumFixIts(), clang_getDiagnosticSeverity(), clang_getRangeEnd(), clang_getRangeStart(), and clang_getSpellingLocation()\&.
.PP
Referenced by PrintDiagnosticSet()\&.
.SS "void PrintDiagnostics (CXTranslationUnit TU)"

.PP
Definition at line 1257 of file c\-index\-test\&.c\&.
.PP
.nf
1257                                             {
1258   CXDiagnosticSet TUSet = clang_getDiagnosticSetFromTU(TU);
1259   PrintDiagnosticSet(TUSet);
1260   clang_disposeDiagnosticSet(TUSet);
1261 }
.fi
.PP
References clang_disposeDiagnosticSet(), clang_getDiagnosticSetFromTU(), and PrintDiagnosticSet()\&.
.SS "void PrintDiagnosticSet (CXDiagnosticSet Set)"

.PP
Definition at line 1246 of file c\-index\-test\&.c\&.
.PP
.nf
1246                                              {
1247   int i = 0, n = clang_getNumDiagnosticsInSet(Set);
1248   for ( ; i != n ; ++i) {
1249     CXDiagnostic Diag = clang_getDiagnosticInSet(Set, i);
1250     CXDiagnosticSet ChildDiags = clang_getChildDiagnostics(Diag);
1251     PrintDiagnostic(Diag);
1252     if (ChildDiags)
1253       PrintDiagnosticSet(ChildDiags);
1254   }  
1255 }
.fi
.PP
References clang_getChildDiagnostics(), clang_getDiagnosticInSet(), clang_getNumDiagnosticsInSet(), and PrintDiagnostic()\&.
.PP
Referenced by PrintDiagnostics()\&.
.SS "void PrintInclusionStack (CXTranslationUnit TU)"

.PP
Definition at line 1440 of file c\-index\-test\&.c\&.
.PP
.nf
1440                                                {
1441   clang_getInclusions(TU, InclusionVisitor, NULL);
1442 }
.fi
.PP
References clang_getInclusions(), and InclusionVisitor()\&.
.SS "void PrintMemoryUsage (CXTranslationUnit TU)"

.PP
Definition at line 1263 of file c\-index\-test\&.c\&.
.PP
.nf
1263                                             {
1264   unsigned long total = 0;
1265   unsigned i = 0;
1266   CXTUResourceUsage usage = clang_getCXTUResourceUsage(TU);
1267   fprintf(stderr, "Memory usage:\n");
1268   for (i = 0 ; i != usage\&.numEntries; ++i) {
1269     const char *name = clang_getTUResourceUsageName(usage\&.entries[i]\&.kind);
1270     unsigned long amount = usage\&.entries[i]\&.amount;
1271     total += amount;
1272     fprintf(stderr, "  %s : %ld bytes (%f MBytes)\n", name, amount,
1273             ((double) amount)/(1024*1024));
1274   }
1275   fprintf(stderr, "  TOTAL = %ld bytes (%f MBytes)\n", total,
1276           ((double) total)/(1024*1024));
1277   clang_disposeCXTUResourceUsage(usage);  
1278 }
.fi
.PP
References clang_disposeCXTUResourceUsage(), clang_getCXTUResourceUsage(), and clang_getTUResourceUsageName()\&.
.SS "void thread_runner (void * client_data_v)"

.PP
Definition at line 4989 of file c\-index\-test\&.c\&.
.PP
.nf
4989                                         {
4990   thread_info *client_data = client_data_v;
4991   client_data->result = client_data->main_func(client_data->argc,
4992                                                client_data->argv);
4993 }
.fi
.PP
References thread_info::argc, thread_info::argv, thread_info::main_func, and thread_info::result\&.
.SS "enum CXChildVisitResult USRVisitor (CXCursor C, CXCursor parent, CXClientData ClientData)"

.PP
Definition at line 1284 of file c\-index\-test\&.c\&.
.PP
.nf
1393                                                             {
1394   VisitorData *Data = (VisitorData *)ClientData;
1395   if (!Data->Filter || (C\&.kind == *(enum CXCursorKind *)Data->Filter)) {
1396     CXString USR = clang_getCursorUSR(C);
1397     const char *cstr = clang_getCString(USR);
1398     if (!cstr || cstr[0] == '\0') {
1399       clang_disposeString(USR);
1400       return CXChildVisit_Recurse;
1401     }
1402     printf("// %s: %s %s", FileCheckPrefix, GetCursorSource(C), cstr);
1403 
1404     PrintCursorExtent(C);
1405     printf("\n");
1406     clang_disposeString(USR);
1407 
1408     return CXChildVisit_Recurse;
1409   }
1410 
1411   return CXChildVisit_Continue;
1412 }
.fi
.SS "int write_pch_file (const char * filename, int argc, const char * argv[])"

.PP
Definition at line 4554 of file c\-index\-test\&.c\&.
.PP
.nf
4554                                                                        {
4555   CXIndex Idx;
4556   CXTranslationUnit TU;
4557   struct CXUnsavedFile *unsaved_files = 0;
4558   int num_unsaved_files = 0;
4559   enum CXErrorCode Err;
4560   int result = 0;
4561   
4562   Idx = clang_createIndex(/* excludeDeclsFromPCH */1, /* displayDiagnostics=*/1);
4563   
4564   if (parse_remapped_files(argc, argv, 0, &unsaved_files, &num_unsaved_files)) {
4565     clang_disposeIndex(Idx);
4566     return -1;
4567   }
4568 
4569   Err = clang_parseTranslationUnit2(
4570       Idx, 0, argv + num_unsaved_files, argc - num_unsaved_files,
4571       unsaved_files, num_unsaved_files,
4572       CXTranslationUnit_Incomplete |
4573           CXTranslationUnit_DetailedPreprocessingRecord |
4574           CXTranslationUnit_ForSerialization,
4575       &TU);
4576   if (Err != CXError_Success) {
4577     fprintf(stderr, "Unable to load translation unit!\n");
4578     describeLibclangFailure(Err);
4579     free_remapped_files(unsaved_files, num_unsaved_files);
4580     clang_disposeTranslationUnit(TU);
4581     clang_disposeIndex(Idx);
4582     return 1;
4583   }
4584 
4585   switch (clang_saveTranslationUnit(TU, filename, 
4586                                     clang_defaultSaveOptions(TU))) {
4587   case CXSaveError_None:
4588     break;
4589 
4590   case CXSaveError_TranslationErrors:
4591     fprintf(stderr, "Unable to write PCH file %s: translation errors\n", 
4592             filename);
4593     result = 2;    
4594     break;
4595 
4596   case CXSaveError_InvalidTU:
4597     fprintf(stderr, "Unable to write PCH file %s: invalid translation unit\n", 
4598             filename);
4599     result = 3;    
4600     break;
4601 
4602   case CXSaveError_Unknown:
4603   default:
4604     fprintf(stderr, "Unable to write PCH file %s: unknown error \n", filename);
4605     result = 1;
4606     break;
4607   }
4608   
4609   clang_disposeTranslationUnit(TU);
4610   free_remapped_files(unsaved_files, num_unsaved_files);
4611   clang_disposeIndex(Idx);
4612   return result;
4613 }
.fi
.PP
References clang_createIndex()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Regions Of Interest (ROI) Profiler from the source code\&.
