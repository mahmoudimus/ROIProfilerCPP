.TH "HagnTool.cpp" 3 "Sun Nov 14 2021" "Version 1.0" "Hagn Tool Performance Counter" \" -*- nroff -*-
.ad l
.nh
.SH NAME
HagnTool.cpp
.SH SYNOPSIS
.br
.PP
\fC#include 'HagnTool\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBVisitor\fP"
.br
.ti -1c
.RI "class \fBConsumer\fP"
.br
.RI "Customizes a Instance of ASTConsumer\&. The \fBConsumer\fP is used by the Frontend Action to traverse the AST Tree\&. "
.ti -1c
.RI "class \fBClangFrontendAction\fP"
.br
.RI "Creates ASTConsumer and returns ASTContext\&. A new \fBClangFrontendAction\fP is created in the main, where the CompilerInstance and the SourceFiles are used to generate a new AST Tree \fBConsumer\fP\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "SourceLocation \fBgetLocationAfterToken\fP (SourceLocation sourceLocation, ASTContext *localContext)"
.br
.RI "Returns Location after Token\&. The end location of a function oder stmt returns the location before a brace or a semicolon\&. The events have to be called after the end token\&. This location is returned by this function\&. "
.ti -1c
.RI "void \fBtraverseChildren\fP (Stmt *funcBody, ASTContext *localContext)"
.br
.RI "Traverses recursively through the body of the specified function body\&. Function Body is a set of statements\&. "
.ti -1c
.RI "int \fBmain\fP (int argc, const char **argv)"
.br
.RI "The entry point of the tool\&. The main functions deals with the input files and options\&. Furthermore the \fBClangFrontendAction\fP will be created and is used to transform the code\&. After transformation the rewritten code will be printed to the specified output file\&. "
.in -1c
.SH "Function Documentation"
.PP 
.SS "SourceLocation getLocationAfterToken (SourceLocation sourceLocation, ASTContext * localContext)"

.PP
Returns Location after Token\&. The end location of a function oder stmt returns the location before a brace or a semicolon\&. The events have to be called after the end token\&. This location is returned by this function\&. ! 
.PP
Definition at line 10 of file HagnTool\&.cpp\&.
.PP
.nf
10                                                                                                 {
11     // get the current token at the specified location
12     Optional <Token> currentToken( clang::Lexer::findNextToken(
13             sourceLocation, localContext->getSourceManager( ),
14             localContext->getLangOpts( )));
15 
16     // if token is raw identifier return last token
17     if ( currentToken->getKind( ) == clang::tok::raw_identifier ) {
18         sourceLocation = sourceLocation\&.getLocWithOffset( -1 );
19     }
20     // if token is semi return this token
21     else if ( currentToken->getKind( ) == clang::tok::semi ) {
22         sourceLocation = sourceLocation\&.getLocWithOffset( 0 );
23     }
24     // if token is brace return next token
25     else if ( currentToken->getKind( ) == clang::tok::r_brace ) {
26         sourceLocation = sourceLocation\&.getLocWithOffset( 1 );
27     }
28 
29     // find location after semicolon
30     SourceLocation locAfterSemi( clang::Lexer::findLocationAfterToken(
31             sourceLocation, clang::tok::semi,
32             localContext->getSourceManager( ),
33             localContext->getLangOpts( ), true ));
34 
35     // find location after brace
36     SourceLocation locAfterBrace( clang::Lexer::findLocationAfterToken(
37             sourceLocation, clang::tok::r_brace,
38             localContext->getSourceManager( ),
39             localContext->getLangOpts( ), true ));
40 
41     // if loc after semi is valid return locAfterSemi
42     if ( currentToken->getKind( ) != clang::tok::r_brace && locAfterSemi\&.isValid( )) {
43         sourceLocation = locAfterSemi;
44     }
45     // if loc after brace is valid return locAfterBrace
46     else if ( currentToken->getKind( ) != clang::tok::r_brace && locAfterBrace\&.isValid( )) {
47         sourceLocation = locAfterBrace;
48     }
49 
50     // if token is brace return current location
51 
52     return sourceLocation;
53 }
.fi
.PP
Referenced by traverseChildren(), and Visitor::VisitStmt()\&.
.SS "int main (int argc, const char ** argv)"

.PP
The entry point of the tool\&. The main functions deals with the input files and options\&. Furthermore the \fBClangFrontendAction\fP will be created and is used to transform the code\&. After transformation the rewritten code will be printed to the specified output file\&. ! 
.PP
Definition at line 371 of file HagnTool\&.cpp\&.
.PP
.nf
371                                         {
372 
373     // runtime start
374     std::chrono::system_clock::time_point startTime = std::chrono::system_clock::now( );
375 
376     // create Common Option Parser
377     auto ExpectedParser = CommonOptionsParser::create( argc, argv, MyToolCategory, llvm::cl::Required );
378 
379     // terminate if specified options are not expected
380     if ( !ExpectedParser ) {
381         llvm::errs( ) << ExpectedParser\&.takeError( );
382         return 1;
383     }
384 
385     // create local parameter variables
386     std::string outputFilename = "output\&.cpp";
387     std::string stmtId = "start";
388 
389     // create the stream for output file
390     std::error_code err_code;
391 
392     // parse arguments
393     for ( int i = 0; i < argc; ++i ) {
394 
395         // if output file is specified
396         if ( std::string( argv[ i ] ) == "-o" ) {
397             outputFilename = std::string( argv[ i + 1 ] );
398         }
399 
400         // if statement id is specified
401         if ( std::string( argv[ i ] ) == "--stmt" ) {
402             stmtId = std::string( argv[ i + 1 ] );
403         }
404     }
405 
406     // Print Hagn Tool Information
407     cout << setw( 82 ) << setfill( '=' ) << "\n";
408     cout << setw( 45 ) << setfill( ' ' ) << "Hagn Tool" << setw( 25 ) << "\n";
409     cout << setw( 83 ) << setfill( '=' ) << "\n\n";
410     cout << "Input File: " << argv[ 1 ] << "\n";
411     cout << "Output File: " << outputFilename << "\n";
412     // print no statement id notification
413     if ( stmtId == "start" ) {
414         cout << "Mode: Annotating Main Function\n";
415     } else {
416         cout << "Mode: Annotate specified Statement\n";
417         cout << "Statement ID: " << stmtId << "\n";
418     }
419 
420     // add statement id to global scope
421     statementOption = stmtId;
422 
423     // set destination of output file to the specified file
424     llvm::raw_fd_ostream dest( outputFilename, err_code );
425 
426     // Parse the options and create new ClangTool
427     CommonOptionsParser &OptionsParser = ExpectedParser\&.get( );
428     ClangTool Tool( OptionsParser\&.getCompilations( ),
429                     OptionsParser\&.getSourcePathList( ));
430 
431     // run the Clang Tool, creating a new FrontendAction
432     int result = Tool\&.run( newFrontendActionFactory<ClangFrontendAction>( )\&.get( ));
433 
434     // add initialization and summary if transformation was successful
435     if ( transformationSuccess ) {
436 
437         // if initialization Location is valid insert includes and create DataStorage Object
438         identifierString\&.pop_back( );
439         if ( initializationLocation\&.isValid( )) {
440             rewriter\&.InsertText( initializationLocation,
441                                  "#include \"\&.\&./lib/DataStorage\&.cpp\"\n""DataStorage dataStorage(\"" +
442                                  identifierString + "\");" );
443         } else {
444             cerr << "Invalid initializationLocation, Line 356";
445             exit( EXIT_FAILURE );
446         }
447 
448         // start an event at the beginning of the main function
449         if ( runtimeStartLocation\&.isValid( )) {
450             rewriter\&.InsertText( runtimeStartLocation, "dataStorage\&.startEvent(0);\n" );
451         } else {
452             cerr << "Invalid runtimeStartLocation, Line 364";
453             exit( EXIT_FAILURE );
454         }
455 
456         // start event and insert time summery as last step in the main function
457         if ( summaryLocation\&.isValid( )) {
458             rewriter\&.InsertText( summaryLocation, "dataStorage\&.endEvent(0);\ndataStorage\&.print();" );
459         } else {
460             cerr << "Invalid summaryLocation, Line 372";
461             exit( EXIT_FAILURE );
462         }
463 
464         // runtime end
465         std::chrono::system_clock::time_point endTime = std::chrono::system_clock::now( );
466         std::chrono::duration<double, std::milli> ms_double = endTime - startTime;
467 
468         // print hagn tool runtime
469         cout << "Runtime: " << ms_double\&.count( ) << "ms\n";
470 
471         // print program finished notification
472         cout << "Success: Yes\n\n";
473 
474         // add transformed code to output file
475         rewriter\&.getEditBuffer( rewriter\&.getSourceMgr( )\&.getMainFileID( ))\&.write( dest );
476 
477 
478     } else {
479         cout << "Success: No\n\n";
480         exit( EXIT_FAILURE );
481     }
482 
483     return result;
484 }
.fi
.SS "void traverseChildren (Stmt * funcBody, ASTContext * localContext)"

.PP
Traverses recursively through the body of the specified function body\&. Function Body is a set of statements\&. ! 
.PP
Definition at line 60 of file HagnTool\&.cpp\&.
.PP
.nf
60                                                                   {
61 
62     // count statements in body and search for parent statements
63     int childrenSize = 0;
64     Stmt *parentStmt = NULL;
65     for ( Stmt::child_iterator i = funcBody->child_begin( ), e = funcBody->child_end( ); i != e; ++i ) {
66         Stmt *currStmt = *i;
67         if ( currStmt->getStmtClass( ) != Stmt::ReturnStmtClass ) {
68             childrenSize++;
69             if ( currStmt->getStmtClass( ) == Stmt::CallExprClass
70                  || currStmt->getStmtClass( ) == Stmt::ForStmtClass
71                  || currStmt->getStmtClass( ) == Stmt::WhileStmtClass
72                  || currStmt->getStmtClass( ) == Stmt::IfStmtClass
73                     ) {
74                 parentStmt = currStmt;
75             }
76         }
77     }
78 
79     // if body has multiple children, annotate all statements with performance counter
80     if ( childrenSize > 1 ) {
81         bool isCompoundedStatement = false;
82         SourceLocation lastEventEndLocation;
83 
84         for ( Stmt::child_iterator i = funcBody->child_begin( ), e = funcBody->child_end( );
85               i != e; ++i ) {
86             Stmt *currStmt = *i;
87             currStmt->getStmtClassName( );
88 
89             if ( currStmt->getStmtClass( ) != Stmt::ReturnStmtClass ) {
90 
91                 SourceLocation beginLoc = currStmt->getBeginLoc( );
92                 SourceLocation endLoc = getLocationAfterToken( currStmt->getEndLoc( ), localContext );
93 
94                 // if statement runtime is not merged
95                 if ( !isCompoundedStatement ) {
96 
97                     // set start time always
98                     rewriter\&.InsertText( beginLoc,
99                                          "dataStorage\&.startEvent(" + std::to_string( internalIdentifier ) + ");\n" );
100 
101                     // if statement is not parent, wait for next statement
102                     if ( currStmt->getStmtClass( ) != Stmt::CallExprClass &&
103                          currStmt->getStmtClass( ) != Stmt::ForStmtClass &&
104                          currStmt->getStmtClass( ) != Stmt::WhileStmtClass &&
105                          currStmt->getStmtClass( ) != Stmt::IfStmtClass
106                             ) {
107 
108                         lastEventEndLocation = endLoc;
109                         isCompoundedStatement = true;
110 
111                         // statement is parent, do not merge runtime
112                     } else {
113                         rewriter\&.InsertText( endLoc,
114                                              "dataStorage\&.endEvent(" + std::to_string( internalIdentifier ) + ");\n" );
115                         // concat stmtclass and stmtid and add to identifierString
116                         int64_t id = currStmt->getID( *localContext );
117                         std::string idString =
118                                 currStmt->getStmtClassName( ) + std::string( " " ) + std::to_string( id );
119                         identifierString += idString + ",";
120 
121                         isCompoundedStatement = false;
122                         internalIdentifier++;
123                     }
124 
125                     // if waiting for next statement
126                 } else {
127 
128                     // if statement is parent, stop last merge and annotate this statement
129                     if ( currStmt->getStmtClass( ) == Stmt::CallExprClass ||
130                          currStmt->getStmtClass( ) == Stmt::ForStmtClass ||
131                          currStmt->getStmtClass( ) == Stmt::WhileStmtClass ||
132                          currStmt->getStmtClass( ) == Stmt::IfStmtClass
133                             ) {
134 
135                         // end old event
136                         rewriter\&.InsertText( beginLoc,
137                                              "dataStorage\&.endEvent(" + std::to_string( internalIdentifier ) +
138                                              ");\n" );
139 
140                         // add compound description to identifier string
141                         identifierString += "CustomCompoundStmt InterID" + to_string( internalIdentifier++ ) + ",";
142 
143                         // start and end new event around parent function
144                         rewriter\&.InsertText( beginLoc,
145                                              "dataStorage\&.startEvent(" + std::to_string( internalIdentifier ) +
146                                              ");\n" );
147                         rewriter\&.InsertText( endLoc,
148                                              "dataStorage\&.endEvent(" + std::to_string( internalIdentifier++ ) +
149                                              ");\n" );
150 
151                         // concat stmtclass and stmtid and add to identifierString
152                         int64_t id = currStmt->getID( *localContext );
153                         std::string idString =
154                                 currStmt->getStmtClassName( ) + std::string( " " ) + std::to_string( id );
155                         identifierString += idString + ",";
156 
157                         isCompoundedStatement = false;
158 
159                         // wait for next statement again
160                     } else {
161                         lastEventEndLocation = endLoc;
162                         isCompoundedStatement = true;
163                     }
164                 }
165             }
166         }
167 
168         // end last event
169         if ( isCompoundedStatement && lastEventEndLocation\&.isValid( )) {
170             rewriter\&.InsertText( lastEventEndLocation,
171                                  "dataStorage\&.endEvent(" + std::to_string( internalIdentifier++ ) + ");\n" );
172             identifierString += "CustomCompoundStmt InterID" + to_string( internalIdentifier ) + ",";
173         }
174 
175         // set transformation successful
176         transformationSuccess = true;
177 
178     }
179         // if body has zero or one statements
180     else {
181         // if one children is parent of another set of statements
182         // call traverseChildren recursively
183         if ( parentStmt != NULL ) {
184             if ( parentStmt->getStmtClass( ) == Stmt::CallExprClass ) {
185                 CallExpr *expr = cast<CallExpr>( parentStmt );
186                 Stmt *nextBody = expr->getDirectCallee( )->getBody( );
187                 traverseChildren( nextBody, localContext );
188             }
189             if ( parentStmt->getStmtClass( ) == Stmt::ForStmtClass ) {
190                 ForStmt *forStmt = cast<ForStmt>( parentStmt );
191                 Stmt *nextBody = forStmt->getBody( );
192                 traverseChildren( nextBody, localContext );
193             }
194             if ( parentStmt->getStmtClass( ) == Stmt::WhileStmtClass ) {
195                 WhileStmt *whileStmt = cast<WhileStmt>( parentStmt );
196                 Stmt *nextBody = whileStmt->getBody( );
197                 traverseChildren( nextBody, localContext );
198             }
199             if ( parentStmt->getStmtClass( ) == Stmt::IfStmtClass ) {
200                 IfStmt *ifStmt = cast<IfStmt>( parentStmt );
201                 Stmt *nextBody = ifStmt->getThen( );
202                 traverseChildren( nextBody, localContext );
203             }
204             // if return is the only statement annotate nothing
205         } else {
206             // cout << "hagn-tool hasn't found any statements!\n";
207         }
208     }
209 }
.fi
.PP
References getLocationAfterToken(), identifierString, internalIdentifier, rewriter, and transformationSuccess\&.
.PP
Referenced by Visitor::VisitFunctionDecl(), and Visitor::VisitStmt()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Hagn Tool Performance Counter from the source code\&.
