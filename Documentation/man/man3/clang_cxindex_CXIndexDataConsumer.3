.TH "clang::cxindex::CXIndexDataConsumer" 3 "Sat Feb 12 2022" "Version 1.2" "Regions Of Interest (ROI) Profiler" \" -*- nroff -*-
.ad l
.nh
.SH NAME
clang::cxindex::CXIndexDataConsumer
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <CXIndexDataConsumer\&.h>\fP
.PP
Inherits index::IndexDataConsumer\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCXIndexDataConsumer\fP (CXClientData clientData, IndexerCallbacks &indexCallbacks, unsigned indexOptions, CXTranslationUnit cxTU)"
.br
.ti -1c
.RI "ASTContext & \fBgetASTContext\fP () const"
.br
.ti -1c
.RI "CXTranslationUnit \fBgetCXTU\fP () const"
.br
.ti -1c
.RI "void \fBsetASTContext\fP (ASTContext &ctx)"
.br
.ti -1c
.RI "void \fBsetPreprocessor\fP (std::shared_ptr< Preprocessor > PP) override"
.br
.ti -1c
.RI "bool \fBshouldSuppressRefs\fP () const"
.br
.ti -1c
.RI "bool \fBshouldIndexFunctionLocalSymbols\fP () const"
.br
.ti -1c
.RI "bool \fBshouldIndexImplicitTemplateInsts\fP () const"
.br
.ti -1c
.RI "bool \fBshouldAbort\fP ()"
.br
.ti -1c
.RI "bool \fBhasDiagnosticCallback\fP () const"
.br
.ti -1c
.RI "void \fBenteredMainFile\fP (const FileEntry *File)"
.br
.ti -1c
.RI "void \fBppIncludedFile\fP (SourceLocation hashLoc, StringRef filename, const FileEntry *File, bool isImport, bool isAngled, bool isModuleImport)"
.br
.ti -1c
.RI "void \fBimportedModule\fP (const ImportDecl *ImportD)"
.br
.ti -1c
.RI "void \fBimportedPCH\fP (const FileEntry *File)"
.br
.ti -1c
.RI "void \fBstartedTranslationUnit\fP ()"
.br
.ti -1c
.RI "void \fBindexDiagnostics\fP ()"
.br
.ti -1c
.RI "void \fBhandleDiagnosticSet\fP (CXDiagnosticSet CXDiagSet)"
.br
.ti -1c
.RI "bool \fBhandleFunction\fP (const FunctionDecl *FD)"
.br
.ti -1c
.RI "bool \fBhandleVar\fP (const VarDecl *D)"
.br
.ti -1c
.RI "bool \fBhandleField\fP (const FieldDecl *D)"
.br
.ti -1c
.RI "bool \fBhandleEnumerator\fP (const EnumConstantDecl *D)"
.br
.ti -1c
.RI "bool \fBhandleTagDecl\fP (const TagDecl *D)"
.br
.ti -1c
.RI "bool \fBhandleTypedefName\fP (const TypedefNameDecl *D)"
.br
.ti -1c
.RI "bool \fBhandleObjCInterface\fP (const ObjCInterfaceDecl *D)"
.br
.ti -1c
.RI "bool \fBhandleObjCImplementation\fP (const ObjCImplementationDecl *D)"
.br
.ti -1c
.RI "bool \fBhandleObjCProtocol\fP (const ObjCProtocolDecl *D)"
.br
.ti -1c
.RI "bool \fBhandleObjCCategory\fP (const ObjCCategoryDecl *D)"
.br
.ti -1c
.RI "bool \fBhandleObjCCategoryImpl\fP (const ObjCCategoryImplDecl *D)"
.br
.ti -1c
.RI "bool \fBhandleObjCMethod\fP (const ObjCMethodDecl *D, SourceLocation Loc)"
.br
.ti -1c
.RI "bool \fBhandleSynthesizedObjCProperty\fP (const ObjCPropertyImplDecl *D)"
.br
.ti -1c
.RI "bool \fBhandleSynthesizedObjCMethod\fP (const ObjCMethodDecl *D, SourceLocation Loc, const DeclContext *LexicalDC)"
.br
.ti -1c
.RI "bool \fBhandleObjCProperty\fP (const ObjCPropertyDecl *D)"
.br
.ti -1c
.RI "bool \fBhandleNamespace\fP (const NamespaceDecl *D)"
.br
.ti -1c
.RI "bool \fBhandleClassTemplate\fP (const ClassTemplateDecl *D)"
.br
.ti -1c
.RI "bool \fBhandleFunctionTemplate\fP (const FunctionTemplateDecl *D)"
.br
.ti -1c
.RI "bool \fBhandleTypeAliasTemplate\fP (const TypeAliasTemplateDecl *D)"
.br
.ti -1c
.RI "bool \fBhandleReference\fP (const NamedDecl *D, SourceLocation Loc, CXCursor Cursor, const NamedDecl *Parent, const DeclContext *DC, const Expr *E=nullptr, CXIdxEntityRefKind Kind=CXIdxEntityRef_Direct, CXSymbolRole Role=CXSymbolRole_None)"
.br
.ti -1c
.RI "bool \fBisNotFromSourceFile\fP (SourceLocation Loc) const"
.br
.ti -1c
.RI "void \fBtranslateLoc\fP (SourceLocation Loc, CXIdxClientFile *indexFile, CXFile *file, unsigned *line, unsigned *column, unsigned *offset)"
.br
.ti -1c
.RI "CXIdxClientContainer \fBgetClientContainerForDC\fP (const DeclContext *DC) const"
.br
.ti -1c
.RI "void \fBaddContainerInMap\fP (const DeclContext *DC, CXIdxClientContainer container)"
.br
.ti -1c
.RI "CXIdxClientEntity \fBgetClientEntity\fP (const Decl *D) const"
.br
.ti -1c
.RI "void \fBsetClientEntity\fP (const Decl *D, CXIdxClientEntity client)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static bool \fBisFunctionLocalDecl\fP (const Decl *D)"
.br
.ti -1c
.RI "static bool \fBisTemplateImplicitInstantiation\fP (const Decl *D)"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBScratchAlloc\fP"
.br
.ti -1c
.RI "class \fBAttrListInfo\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 275 of file CXIndexDataConsumer\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "clang::cxindex::CXIndexDataConsumer::CXIndexDataConsumer (CXClientData clientData, IndexerCallbacks & indexCallbacks, unsigned indexOptions, CXTranslationUnit cxTU)\fC [inline]\fP"

.PP
Definition at line 334 of file CXIndexDataConsumer\&.h\&.
.PP
.nf
336     : Ctx(nullptr), ClientData(clientData), CB(indexCallbacks),
337       IndexOptions(indexOptions), CXTU(cxTU),
338       StrScratch(), StrAdapterCount(0) { }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void CXIndexDataConsumer::addContainerInMap (const DeclContext * DC, CXIdxClientContainer container)"

.PP
Definition at line 941 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
942                                                                         {
943   if (!DC)
944     return;
945 
946   ContainerMapTy::iterator I = ContainerMap\&.find(DC);
947   if (I == ContainerMap\&.end()) {
948     if (container)
949       ContainerMap[DC] = container;
950     return;
951   }
952   // Allow changing the container of a previously seen DeclContext so we
953   // can handle invalid user code, like a function re-definition\&.
954   if (container)
955     I->second = container;
956   else
957     ContainerMap\&.erase(I);
958 }
.fi
.PP
Referenced by clang_index_setClientContainer(), and startedTranslationUnit()\&.
.SS "void CXIndexDataConsumer::enteredMainFile (const FileEntry * File)"

.PP
Definition at line 450 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
450                                                                {
451   if (File && CB\&.enteredMainFile) {
452     CXIdxClientFile idxFile =
453       CB\&.enteredMainFile(ClientData,
454                          static_cast<CXFile>(const_cast<FileEntry *>(File)),
455                          nullptr);
456     FileMap[File] = idxFile;
457   }
458 }
.fi
.SS "ASTContext& clang::cxindex::CXIndexDataConsumer::getASTContext () const\fC [inline]\fP"

.PP
Definition at line 340 of file CXIndexDataConsumer\&.h\&.
.PP
.nf
340 { return *Ctx; }
.fi
.PP
Referenced by clang_indexLoc_getCXSourceLocation()\&.
.SS "CXIdxClientContainer CXIndexDataConsumer::getClientContainerForDC (const DeclContext * DC) const"

.PP
Definition at line 1069 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
1069                                                                         {
1070   if (!DC)
1071     return nullptr;
1072 
1073   ContainerMapTy::const_iterator I = ContainerMap\&.find(DC);
1074   if (I == ContainerMap\&.end())
1075     return nullptr;
1076 
1077   return I->second;
1078 }
.fi
.PP
Referenced by clang_index_getClientContainer()\&.
.SS "CXIdxClientEntity CXIndexDataConsumer::getClientEntity (const Decl * D) const"

.PP
Definition at line 960 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
960                                                                           {
961   if (!D)
962     return nullptr;
963   EntityMapTy::const_iterator I = EntityMap\&.find(D);
964   if (I == EntityMap\&.end())
965     return nullptr;
966   return I->second;
967 }
.fi
.PP
Referenced by clang_index_getClientEntity()\&.
.SS "CXTranslationUnit clang::cxindex::CXIndexDataConsumer::getCXTU () const\fC [inline]\fP"

.PP
Definition at line 341 of file CXIndexDataConsumer\&.h\&.
.PP
.nf
341 { return CXTU; }
.fi
.PP
Referenced by indexDiagnostics()\&.
.SS "bool CXIndexDataConsumer::handleClassTemplate (const ClassTemplateDecl * D)"

.PP
Definition at line 867 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
867                                                                         {
868   return handleCXXRecordDecl(D->getTemplatedDecl(), D);
869 }
.fi
.SS "void CXIndexDataConsumer::handleDiagnosticSet (CXDiagnosticSet CXDiagSet)"

.PP
Definition at line 534 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
534                                                                     {
535   if (!CB\&.diagnostic)
536     return;
537 
538   CB\&.diagnostic(ClientData, CXDiagSet, nullptr);
539 }
.fi
.PP
Referenced by indexDiagnostics()\&.
.SS "bool CXIndexDataConsumer::handleEnumerator (const EnumConstantDecl * D)"

.PP
Definition at line 635 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
635                                                                     {
636   DeclInfo DInfo(/*isRedeclaration=*/false, /*isDefinition=*/true,
637                  /*isContainer=*/false);
638   return handleDecl(D, D->getLocation(), getCursor(D), DInfo);
639 }
.fi
.SS "bool CXIndexDataConsumer::handleField (const FieldDecl * D)"

.PP
Definition at line 629 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
629                                                         {
630   DeclInfo DInfo(/*isRedeclaration=*/false, /*isDefinition=*/true,
631                  /*isContainer=*/false);
632   return handleDecl(D, D->getLocation(), getCursor(D), DInfo);
633 }
.fi
.SS "bool CXIndexDataConsumer::handleFunction (const FunctionDecl * FD)"

.PP
Definition at line 607 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
607                                                               {
608   bool isDef = D->isThisDeclarationADefinition();
609   bool isContainer = isDef;
610   bool isSkipped = false;
611   if (D->hasSkippedBody()) {
612     isSkipped = true;
613     isDef = true;
614     isContainer = false;
615   }
616 
617   DeclInfo DInfo(!D->isFirstDecl(), isDef, isContainer);
618   if (isSkipped)
619     DInfo\&.flags |= CXIdxDeclFlag_Skipped;
620   return handleDecl(D, D->getLocation(), getCursor(D), DInfo);
621 }
.fi
.SS "bool CXIndexDataConsumer::handleFunctionTemplate (const FunctionTemplateDecl * D)"

.PP
Definition at line 871 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
871                                                                               {
872   DeclInfo DInfo(/*isRedeclaration=*/!D->isCanonicalDecl(),
873                  /*isDefinition=*/D->isThisDeclarationADefinition(),
874                  /*isContainer=*/D->isThisDeclarationADefinition());
875   return handleDecl(D, D->getLocation(), getCursor(D), DInfo);
876 }
.fi
.SS "bool CXIndexDataConsumer::handleNamespace (const NamespaceDecl * D)"

.PP
Definition at line 860 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
860                                                                 {
861   DeclInfo DInfo(/*isRedeclaration=*/!D->isOriginalNamespace(),
862                  /*isDefinition=*/true,
863                  /*isContainer=*/true);
864   return handleDecl(D, D->getLocation(), getCursor(D), DInfo);
865 }
.fi
.SS "bool CXIndexDataConsumer::handleObjCCategory (const ObjCCategoryDecl * D)"

.PP
Definition at line 741 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
741                                                                       {
742   ScratchAlloc SA(*this);
743 
744   ObjCCategoryDeclInfo CatDInfo(/*isImplementation=*/false);
745   EntityInfo ClassEntity;
746   const ObjCInterfaceDecl *IFaceD = D->getClassInterface();
747   SourceLocation ClassLoc = D->getLocation();
748   SourceLocation CategoryLoc = D->IsClassExtension() ? ClassLoc
749                                                      : D->getCategoryNameLoc();
750   getEntityInfo(IFaceD, ClassEntity, SA);
751 
752   if (shouldSuppressRefs())
753     markEntityOccurrenceInFile(IFaceD, ClassLoc);
754 
755   ObjCProtocolListInfo ProtInfo(D->getReferencedProtocols(), *this, SA);
756   
757   CatDInfo\&.ObjCCatDeclInfo\&.containerInfo = &CatDInfo\&.ObjCContDeclInfo;
758   if (IFaceD) {
759     CatDInfo\&.ObjCCatDeclInfo\&.objcClass = &ClassEntity;
760     CatDInfo\&.ObjCCatDeclInfo\&.classCursor =
761         MakeCursorObjCClassRef(IFaceD, ClassLoc, CXTU);
762   } else {
763     CatDInfo\&.ObjCCatDeclInfo\&.objcClass = nullptr;
764     CatDInfo\&.ObjCCatDeclInfo\&.classCursor = clang_getNullCursor();
765   }
766   CatDInfo\&.ObjCCatDeclInfo\&.classLoc = getIndexLoc(ClassLoc);
767   CatDInfo\&.ObjCProtoListInfo = ProtInfo\&.getListInfo();
768   CatDInfo\&.ObjCCatDeclInfo\&.protocols = &CatDInfo\&.ObjCProtoListInfo;
769 
770   return handleObjCContainer(D, CategoryLoc, getCursor(D), CatDInfo);
771 }
.fi
.PP
References clang_getNullCursor(), clang::cxcursor::MakeCursorObjCClassRef(), clang::cxindex::ObjCCategoryDeclInfo::ObjCCatDeclInfo, clang::cxindex::ObjCContainerDeclInfo::ObjCContDeclInfo, clang::cxindex::ObjCCategoryDeclInfo::ObjCProtoListInfo, and shouldSuppressRefs()\&.
.SS "bool CXIndexDataConsumer::handleObjCCategoryImpl (const ObjCCategoryImplDecl * D)"

.PP
Definition at line 773 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
773                                                                               {
774   ScratchAlloc SA(*this);
775 
776   const ObjCCategoryDecl *CatD = D->getCategoryDecl();
777   ObjCCategoryDeclInfo CatDInfo(/*isImplementation=*/true);
778   EntityInfo ClassEntity;
779   const ObjCInterfaceDecl *IFaceD = CatD->getClassInterface();
780   SourceLocation ClassLoc = D->getLocation();
781   SourceLocation CategoryLoc = D->getCategoryNameLoc();
782   getEntityInfo(IFaceD, ClassEntity, SA);
783 
784   if (shouldSuppressRefs())
785     markEntityOccurrenceInFile(IFaceD, ClassLoc);
786 
787   CatDInfo\&.ObjCCatDeclInfo\&.containerInfo = &CatDInfo\&.ObjCContDeclInfo;
788   if (IFaceD) {
789     CatDInfo\&.ObjCCatDeclInfo\&.objcClass = &ClassEntity;
790     CatDInfo\&.ObjCCatDeclInfo\&.classCursor =
791         MakeCursorObjCClassRef(IFaceD, ClassLoc, CXTU);
792   } else {
793     CatDInfo\&.ObjCCatDeclInfo\&.objcClass = nullptr;
794     CatDInfo\&.ObjCCatDeclInfo\&.classCursor = clang_getNullCursor();
795   }
796   CatDInfo\&.ObjCCatDeclInfo\&.classLoc = getIndexLoc(ClassLoc);
797   CatDInfo\&.ObjCCatDeclInfo\&.protocols = nullptr;
798 
799   return handleObjCContainer(D, CategoryLoc, getCursor(D), CatDInfo);
800 }
.fi
.PP
References clang_getNullCursor(), clang::cxcursor::MakeCursorObjCClassRef(), clang::cxindex::ObjCCategoryDeclInfo::ObjCCatDeclInfo, clang::cxindex::ObjCContainerDeclInfo::ObjCContDeclInfo, and shouldSuppressRefs()\&.
.SS "bool CXIndexDataConsumer::handleObjCImplementation (const ObjCImplementationDecl * D)"

.PP
Definition at line 704 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
705                                                                                {
706   ObjCContainerDeclInfo ContDInfo(/*isForwardRef=*/false,
707                       /*isRedeclaration=*/true,
708                       /*isImplementation=*/true);
709   return handleObjCContainer(D, D->getLocation(), getCursor(D), ContDInfo);
710 }
.fi
.SS "bool CXIndexDataConsumer::handleObjCInterface (const ObjCInterfaceDecl * D)"

.PP
Definition at line 656 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
656                                                                         {
657   // For @class forward declarations, suppress them the same way as references\&.
658   if (!D->isThisDeclarationADefinition()) {
659     if (shouldSuppressRefs() && markEntityOccurrenceInFile(D, D->getLocation()))
660       return false; // already occurred\&.
661 
662     // FIXME: This seems like the wrong definition for redeclaration\&.
663     bool isRedeclaration = D->hasDefinition() || D->getPreviousDecl();
664     ObjCContainerDeclInfo ContDInfo(/*isForwardRef=*/true, isRedeclaration,
665                                     /*isImplementation=*/false);
666     return handleObjCContainer(D, D->getLocation(),
667                                MakeCursorObjCClassRef(D, D->getLocation(),
668                                                       CXTU), 
669                                ContDInfo);
670   }
671 
672   ScratchAlloc SA(*this);
673 
674   CXIdxBaseClassInfo BaseClass;
675   EntityInfo BaseEntity;
676   BaseClass\&.cursor = clang_getNullCursor();
677   if (ObjCInterfaceDecl *SuperD = D->getSuperClass()) {
678     getEntityInfo(SuperD, BaseEntity, SA);
679     SourceLocation SuperLoc = D->getSuperClassLoc();
680     BaseClass\&.base = &BaseEntity;
681     BaseClass\&.cursor = MakeCursorObjCSuperClassRef(SuperD, SuperLoc, CXTU);
682     BaseClass\&.loc = getIndexLoc(SuperLoc);
683 
684     if (shouldSuppressRefs())
685       markEntityOccurrenceInFile(SuperD, SuperLoc);
686   }
687   
688   ObjCProtocolList EmptyProtoList;
689   ObjCProtocolListInfo ProtInfo(D->isThisDeclarationADefinition() 
690                                   ? D->getReferencedProtocols()
691                                   : EmptyProtoList, 
692                                 *this, SA);
693   
694   ObjCInterfaceDeclInfo InterInfo(D);
695   InterInfo\&.ObjCProtoListInfo = ProtInfo\&.getListInfo();
696   InterInfo\&.ObjCInterDeclInfo\&.containerInfo = &InterInfo\&.ObjCContDeclInfo;
697   InterInfo\&.ObjCInterDeclInfo\&.superInfo = D->getSuperClass() ? &BaseClass
698                                                              : nullptr;
699   InterInfo\&.ObjCInterDeclInfo\&.protocols = &InterInfo\&.ObjCProtoListInfo;
700 
701   return handleObjCContainer(D, D->getLocation(), getCursor(D), InterInfo);
702 }
.fi
.PP
References clang_getNullCursor(), clang::cxcursor::MakeCursorObjCClassRef(), clang::cxcursor::MakeCursorObjCSuperClassRef(), clang::cxindex::ObjCContainerDeclInfo::ObjCContDeclInfo, clang::cxindex::ObjCInterfaceDeclInfo::ObjCInterDeclInfo, clang::cxindex::ObjCInterfaceDeclInfo::ObjCProtoListInfo, and shouldSuppressRefs()\&.
.SS "bool CXIndexDataConsumer::handleObjCMethod (const ObjCMethodDecl * D, SourceLocation Loc)"

.PP
Definition at line 802 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
803                                                                {
804   bool isDef = D->isThisDeclarationADefinition();
805   bool isContainer = isDef;
806   bool isSkipped = false;
807   if (D->hasSkippedBody()) {
808     isSkipped = true;
809     isDef = true;
810     isContainer = false;
811   }
812 
813   DeclInfo DInfo(!D->isCanonicalDecl(), isDef, isContainer);
814   if (isSkipped)
815     DInfo\&.flags |= CXIdxDeclFlag_Skipped;
816   return handleDecl(D, Loc, getCursor(D), DInfo);
817 }
.fi
.SS "bool CXIndexDataConsumer::handleObjCProperty (const ObjCPropertyDecl * D)"

.PP
Definition at line 835 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
835                                                                       {
836   ScratchAlloc SA(*this);
837 
838   ObjCPropertyDeclInfo DInfo;
839   EntityInfo GetterEntity;
840   EntityInfo SetterEntity;
841 
842   DInfo\&.ObjCPropDeclInfo\&.declInfo = &DInfo;
843 
844   if (ObjCMethodDecl *Getter = D->getGetterMethodDecl()) {
845     getEntityInfo(Getter, GetterEntity, SA);
846     DInfo\&.ObjCPropDeclInfo\&.getter = &GetterEntity;
847   } else {
848     DInfo\&.ObjCPropDeclInfo\&.getter = nullptr;
849   }
850   if (ObjCMethodDecl *Setter = D->getSetterMethodDecl()) {
851     getEntityInfo(Setter, SetterEntity, SA);
852     DInfo\&.ObjCPropDeclInfo\&.setter = &SetterEntity;
853   } else {
854     DInfo\&.ObjCPropDeclInfo\&.setter = nullptr;
855   }
856 
857   return handleDecl(D, D->getLocation(), getCursor(D), DInfo);
858 }
.fi
.PP
References clang::cxindex::ObjCPropertyDeclInfo::ObjCPropDeclInfo\&.
.SS "bool CXIndexDataConsumer::handleObjCProtocol (const ObjCProtocolDecl * D)"

.PP
Definition at line 712 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
712                                                                       {
713   if (!D->isThisDeclarationADefinition()) {
714     if (shouldSuppressRefs() && markEntityOccurrenceInFile(D, D->getLocation()))
715       return false; // already occurred\&.
716     
717     // FIXME: This seems like the wrong definition for redeclaration\&.
718     bool isRedeclaration = D->hasDefinition() || D->getPreviousDecl();
719     ObjCContainerDeclInfo ContDInfo(/*isForwardRef=*/true,
720                                     isRedeclaration,
721                                     /*isImplementation=*/false);
722     return handleObjCContainer(D, D->getLocation(), 
723                                MakeCursorObjCProtocolRef(D, D->getLocation(),
724                                                          CXTU),
725                                ContDInfo);    
726   }
727   
728   ScratchAlloc SA(*this);
729   ObjCProtocolList EmptyProtoList;
730   ObjCProtocolListInfo ProtListInfo(D->isThisDeclarationADefinition()
731                                       ? D->getReferencedProtocols()
732                                       : EmptyProtoList,
733                                     *this, SA);
734   
735   ObjCProtocolDeclInfo ProtInfo(D);
736   ProtInfo\&.ObjCProtoRefListInfo = ProtListInfo\&.getListInfo();
737 
738   return handleObjCContainer(D, D->getLocation(), getCursor(D), ProtInfo);
739 }
.fi
.PP
References clang::cxcursor::MakeCursorObjCProtocolRef(), clang::cxindex::ObjCProtocolDeclInfo::ObjCProtoRefListInfo, and shouldSuppressRefs()\&.
.SS "bool CXIndexDataConsumer::handleReference (const NamedDecl * D, SourceLocation Loc, CXCursor Cursor, const NamedDecl * Parent, const DeclContext * DC, const Expr * E = \fCnullptr\fP, CXIdxEntityRefKind Kind = \fCCXIdxEntityRef_Direct\fP, CXSymbolRole Role = \fCCXSymbolRole_None\fP)"

.PP
Definition at line 884 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
890                                                          {
891   if (!CB\&.indexEntityReference)
892     return false;
893 
894   if (!D || !DC)
895     return false;
896   if (Loc\&.isInvalid())
897     return false;
898   if (!shouldIndexFunctionLocalSymbols() && isFunctionLocalDecl(D))
899     return false;
900   if (isNotFromSourceFile(D->getLocation()))
901     return false;
902   if (D->isImplicit() && shouldIgnoreIfImplicit(D))
903     return false;
904 
905   if (shouldSuppressRefs()) {
906     if (markEntityOccurrenceInFile(D, Loc))
907       return false; // already occurred\&.
908   }
909 
910   ScratchAlloc SA(*this);
911   EntityInfo RefEntity, ParentEntity;
912   getEntityInfo(D, RefEntity, SA);
913   if (!RefEntity\&.USR)
914     return false;
915 
916   getEntityInfo(Parent, ParentEntity, SA);
917 
918   ContainerInfo Container;
919   getContainerInfo(DC, Container);
920 
921   CXIdxEntityRefInfo Info = { Kind,
922                               Cursor,
923                               getIndexLoc(Loc),
924                               &RefEntity,
925                               Parent ? &ParentEntity : nullptr,
926                               &Container,
927                               Role };
928   CB\&.indexEntityReference(ClientData, &Info);
929   return true;
930 }
.fi
.PP
Referenced by handleSynthesizedObjCProperty()\&.
.SS "bool CXIndexDataConsumer::handleSynthesizedObjCMethod (const ObjCMethodDecl * D, SourceLocation Loc, const DeclContext * LexicalDC)"

.PP
Definition at line 827 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
829                                                                                {
830   DeclInfo DInfo(/*isRedeclaration=*/true, /*isDefinition=*/true,
831                  /*isContainer=*/false);
832   return handleDecl(D, Loc, getCursor(D), DInfo, LexicalDC, D->getDeclContext());
833 }
.fi
.SS "bool CXIndexDataConsumer::handleSynthesizedObjCProperty (const ObjCPropertyImplDecl * D)"

.PP
Definition at line 819 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
820                                                                                {
821   ObjCPropertyDecl *PD = D->getPropertyDecl();
822   auto *DC = D->getDeclContext();
823   return handleReference(PD, D->getLocation(), getCursor(D),
824                          dyn_cast<NamedDecl>(DC), DC);
825 }
.fi
.PP
References handleReference()\&.
.SS "bool CXIndexDataConsumer::handleTagDecl (const TagDecl * D)"

.PP
Definition at line 641 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
641                                                         {
642   if (const CXXRecordDecl *CXXRD = dyn_cast<CXXRecordDecl>(D))
643     return handleCXXRecordDecl(CXXRD, D);
644 
645   DeclInfo DInfo(!D->isFirstDecl(), D->isThisDeclarationADefinition(),
646                  D->isThisDeclarationADefinition());
647   return handleDecl(D, D->getLocation(), getCursor(D), DInfo);
648 }
.fi
.SS "bool CXIndexDataConsumer::handleTypeAliasTemplate (const TypeAliasTemplateDecl * D)"

.PP
Definition at line 878 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
878                                                                                 {
879   DeclInfo DInfo(/*isRedeclaration=*/!D->isCanonicalDecl(),
880                  /*isDefinition=*/true, /*isContainer=*/false);
881   return handleDecl(D, D->getLocation(), getCursor(D), DInfo);
882 }
.fi
.SS "bool CXIndexDataConsumer::handleTypedefName (const TypedefNameDecl * D)"

.PP
Definition at line 650 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
650                                                                     {
651   DeclInfo DInfo(!D->isFirstDecl(), /*isDefinition=*/true,
652                  /*isContainer=*/false);
653   return handleDecl(D, D->getLocation(), getCursor(D), DInfo);
654 }
.fi
.SS "bool CXIndexDataConsumer::handleVar (const VarDecl * D)"

.PP
Definition at line 623 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
623                                                     {
624   DeclInfo DInfo(!D->isFirstDecl(), D->isThisDeclarationADefinition(),
625                  /*isContainer=*/false);
626   return handleDecl(D, D->getLocation(), getCursor(D), DInfo);
627 }
.fi
.SS "bool clang::cxindex::CXIndexDataConsumer::hasDiagnosticCallback () const\fC [inline]\fP"

.PP
Definition at line 362 of file CXIndexDataConsumer\&.h\&.
.PP
.nf
362 { return CB\&.diagnostic; }
.fi
.PP
Referenced by indexDiagnostics()\&.
.SS "void CXIndexDataConsumer::importedModule (const ImportDecl * ImportD)"

.PP
Definition at line 478 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
478                                                                   {
479   if (!CB\&.importedASTFile)
480     return;
481 
482   Module *Mod = ImportD->getImportedModule();
483   if (!Mod)
484     return;
485 
486   // If the imported module is part of the top-level module that we're
487   // indexing, it doesn't correspond to an imported AST file\&.
488   // FIXME: This assumes that AST files and top-level modules directly
489   // correspond, which is unlikely to remain true forever\&.
490   if (Module *SrcMod = ImportD->getImportedOwningModule())
491     if (SrcMod->getTopLevelModule() == Mod->getTopLevelModule())
492       return;
493 
494   FileEntry *FE = nullptr;
495   if (auto File = Mod->getASTFile())
496     FE = const_cast<FileEntry *>(&File->getFileEntry());
497   CXIdxImportedASTFileInfo Info = {static_cast<CXFile>(FE), Mod,
498                                    getIndexLoc(ImportD->getLocation()),
499                                    ImportD->isImplicit()};
500   CXIdxClientASTFile astFile = CB\&.importedASTFile(ClientData, &Info);
501   (void)astFile;
502 }
.fi
.SS "void CXIndexDataConsumer::importedPCH (const FileEntry * File)"

.PP
Definition at line 504 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
504                                                            {
505   if (!CB\&.importedASTFile)
506     return;
507 
508   CXIdxImportedASTFileInfo Info = {
509                                     static_cast<CXFile>(
510                                       const_cast<FileEntry *>(File)),
511                                     /*module=*/nullptr,
512                                     getIndexLoc(SourceLocation()),
513                                     /*isImplicit=*/false
514                                   };
515   CXIdxClientASTFile astFile = CB\&.importedASTFile(ClientData, &Info);
516   (void)astFile;
517 }
.fi
.SS "void CXIndexDataConsumer::indexDiagnostics ()"

.PP
Definition at line 526 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
526                                            {
527   if (!hasDiagnosticCallback())
528     return;
529 
530   CXDiagnosticSetImpl *DiagSet = cxdiag::lazyCreateDiags(getCXTU());
531   handleDiagnosticSet(DiagSet);
532 }
.fi
.PP
References getCXTU(), handleDiagnosticSet(), hasDiagnosticCallback(), and clang::cxdiag::lazyCreateDiags()\&.
.SS "bool CXIndexDataConsumer::isFunctionLocalDecl (const Decl * D)\fC [static]\fP"

.PP
Definition at line 420 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
420                                                            {
421   assert(D);
422 
423   if (!D->getParentFunctionOrMethod())
424     return false;
425 
426   if (const NamedDecl *ND = dyn_cast<NamedDecl>(D)) {
427     switch (ND->getFormalLinkage()) {
428     case NoLinkage:
429     case InternalLinkage:
430       return true;
431     case VisibleNoLinkage:
432     case ModuleInternalLinkage:
433     case UniqueExternalLinkage:
434       llvm_unreachable("Not a sema linkage");
435     case ModuleLinkage:
436     case ExternalLinkage:
437       return false;
438     }
439   }
440 
441   return true;
442 }
.fi
.SS "bool CXIndexDataConsumer::isNotFromSourceFile (SourceLocation Loc) const"

.PP
Definition at line 932 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
932                                                                       {
933   if (Loc\&.isInvalid())
934     return true;
935   SourceManager &SM = Ctx->getSourceManager();
936   SourceLocation FileLoc = SM\&.getFileLoc(Loc);
937   FileID FID = SM\&.getFileID(FileLoc);
938   return SM\&.getFileEntryForID(FID) == nullptr;
939 }
.fi
.SS "bool CXIndexDataConsumer::isTemplateImplicitInstantiation (const Decl * D)\fC [static]\fP"

.PP
Definition at line 1229 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
1229                                                                        {
1230   if (const ClassTemplateSpecializationDecl *
1231         SD = dyn_cast<ClassTemplateSpecializationDecl>(D)) {
1232     return SD->getSpecializationKind() == TSK_ImplicitInstantiation;
1233   }
1234   if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {
1235     return FD->getTemplateSpecializationKind() == TSK_ImplicitInstantiation;
1236   }
1237   return false;
1238 }
.fi
.SS "void CXIndexDataConsumer::ppIncludedFile (SourceLocation hashLoc, StringRef filename, const FileEntry * File, bool isImport, bool isAngled, bool isModuleImport)"

.PP
Definition at line 460 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
464                                                           {
465   if (!CB\&.ppIncludedFile)
466     return;
467 
468   ScratchAlloc SA(*this);
469   CXIdxIncludedFileInfo Info = { getIndexLoc(hashLoc),
470                                  SA\&.toCStr(filename),
471                                  static_cast<CXFile>(
472                                    const_cast<FileEntry *>(File)),
473                                  isImport, isAngled, isModuleImport };
474   CXIdxClientFile idxFile = CB\&.ppIncludedFile(ClientData, &Info);
475   FileMap[File] = idxFile;
476 }
.fi
.PP
References clang::cxindex::ScratchAlloc::toCStr()\&.
.SS "void CXIndexDataConsumer::setASTContext (ASTContext & ctx)"

.PP
Definition at line 411 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
411                                                        {
412   Ctx = &ctx;
413   cxtu::getASTUnit(CXTU)->setASTContext(&ctx);
414 }
.fi
.SS "void CXIndexDataConsumer::setClientEntity (const Decl * D, CXIdxClientEntity client)"

.PP
Definition at line 969 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
969                                                                                  {
970   if (!D)
971     return;
972   EntityMap[D] = client;
973 }
.fi
.PP
Referenced by clang_index_setClientEntity()\&.
.SS "void CXIndexDataConsumer::setPreprocessor (std::shared_ptr< Preprocessor > PP)\fC [override]\fP"

.PP
Definition at line 416 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
416                                                                         {
417   cxtu::getASTUnit(CXTU)->setPreprocessor(std::move(PP));
418 }
.fi
.SS "bool CXIndexDataConsumer::shouldAbort ()"

.PP
Definition at line 444 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
444                                       {
445   if (!CB\&.abortQuery)
446     return false;
447   return CB\&.abortQuery(ClientData, nullptr);
448 }
.fi
.SS "bool clang::cxindex::CXIndexDataConsumer::shouldIndexFunctionLocalSymbols () const\fC [inline]\fP"

.PP
Definition at line 350 of file CXIndexDataConsumer\&.h\&.
.PP
.nf
350                                                {
351     return IndexOptions & CXIndexOpt_IndexFunctionLocalSymbols;
352   }
.fi
.SS "bool clang::cxindex::CXIndexDataConsumer::shouldIndexImplicitTemplateInsts () const\fC [inline]\fP"

.PP
Definition at line 354 of file CXIndexDataConsumer\&.h\&.
.PP
.nf
354                                                 {
355     return IndexOptions & CXIndexOpt_IndexImplicitTemplateInstantiations;
356   }
.fi
.SS "bool clang::cxindex::CXIndexDataConsumer::shouldSuppressRefs () const\fC [inline]\fP"

.PP
Definition at line 346 of file CXIndexDataConsumer\&.h\&.
.PP
.nf
346                                   {
347     return IndexOptions & CXIndexOpt_SuppressRedundantRefs;
348   }
.fi
.PP
Referenced by handleObjCCategory(), handleObjCCategoryImpl(), handleObjCInterface(), and handleObjCProtocol()\&.
.SS "void CXIndexDataConsumer::startedTranslationUnit ()"

.PP
Definition at line 519 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
519                                                  {
520   CXIdxClientContainer idxCont = nullptr;
521   if (CB\&.startedTranslationUnit)
522     idxCont = CB\&.startedTranslationUnit(ClientData, nullptr);
523   addContainerInMap(Ctx->getTranslationUnitDecl(), idxCont);
524 }
.fi
.PP
References addContainerInMap()\&.
.SS "void CXIndexDataConsumer::translateLoc (SourceLocation Loc, CXIdxClientFile * indexFile, CXFile * file, unsigned * line, unsigned * column, unsigned * offset)"

.PP
Definition at line 1101 of file CXIndexDataConsumer\&.cpp\&.
.PP
.nf
1104                                                      {
1105   if (Loc\&.isInvalid())
1106     return;
1107 
1108   SourceManager &SM = Ctx->getSourceManager();
1109   Loc = SM\&.getFileLoc(Loc);
1110 
1111   std::pair<FileID, unsigned> LocInfo = SM\&.getDecomposedLoc(Loc);
1112   FileID FID = LocInfo\&.first;
1113   unsigned FileOffset = LocInfo\&.second;
1114 
1115   if (FID\&.isInvalid())
1116     return;
1117   
1118   const FileEntry *FE = SM\&.getFileEntryForID(FID);
1119   if (indexFile)
1120     *indexFile = getIndexFile(FE);
1121   if (file)
1122     *file = const_cast<FileEntry *>(FE);
1123   if (line)
1124     *line = SM\&.getLineNumber(FID, FileOffset);
1125   if (column)
1126     *column = SM\&.getColumnNumber(FID, FileOffset);
1127   if (offset)
1128     *offset = FileOffset;
1129 }
.fi
.PP
Referenced by clang_indexLoc_getFileLocation()\&.
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBAttrListInfo\fP\fC [friend]\fP"

.PP
Definition at line 331 of file CXIndexDataConsumer\&.h\&.
.SS "friend class \fBScratchAlloc\fP\fC [friend]\fP"

.PP
Definition at line 296 of file CXIndexDataConsumer\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Regions Of Interest (ROI) Profiler from the source code\&.
