.TH "BitArray" 3 "Sat Feb 12 2022" "Version 1.2" "Regions Of Interest (ROI) Profiler" \" -*- nroff -*-
.ad l
.nh
.SH NAME
BitArray
.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBBitArray\fP (size_t size)"
.br
.ti -1c
.RI "\fB~BitArray\fP ()"
.br
.ti -1c
.RI "bool \fBget\fP (size_t n) const"
.br
.ti -1c
.RI "void \fBsetFlagsFalse\fP (size_t n, size_t skip)"
.br
.ti -1c
.RI "\fBBitArray\fP (size_t size)"
.br
.ti -1c
.RI "\fB~BitArray\fP ()"
.br
.ti -1c
.RI "bool \fBget\fP (size_t n) const"
.br
.ti -1c
.RI "void \fBsetFlagsFalse\fP (size_t n, size_t skip)"
.br
.ti -1c
.RI "\fBBitArray\fP (size_t size)"
.br
.ti -1c
.RI "\fB~BitArray\fP ()"
.br
.ti -1c
.RI "bool \fBget\fP (size_t n) const"
.br
.ti -1c
.RI "void \fBsetFlagsFalse\fP (size_t n, size_t skip)"
.br
.ti -1c
.RI "\fBBitArray\fP (size_t size)"
.br
.ti -1c
.RI "\fB~BitArray\fP ()"
.br
.ti -1c
.RI "bool \fBget\fP (size_t n) const"
.br
.ti -1c
.RI "void \fBsetFlagsFalse\fP (size_t n, size_t skip)"
.br
.ti -1c
.RI "\fBBitArray\fP (size_t size)"
.br
.ti -1c
.RI "\fB~BitArray\fP ()"
.br
.ti -1c
.RI "bool \fBget\fP (size_t n) const"
.br
.ti -1c
.RI "void \fBsetFlagsFalse\fP (size_t n, size_t skip)"
.br
.ti -1c
.RI "\fBBitArray\fP (size_t size)"
.br
.ti -1c
.RI "\fB~BitArray\fP ()"
.br
.ti -1c
.RI "bool \fBget\fP (size_t n) const"
.br
.ti -1c
.RI "void \fBsetFlagsFalse\fP (size_t n, size_t skip)"
.br
.ti -1c
.RI "\fBBitArray\fP (size_t size)"
.br
.ti -1c
.RI "\fB~BitArray\fP ()"
.br
.ti -1c
.RI "bool \fBget\fP (size_t n) const"
.br
.ti -1c
.RI "void \fBsetFlagsFalse\fP (size_t n, size_t skip)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static constexpr uint32_t \fBrol\fP (uint32_t x, uint32_t n)"
.br
.ti -1c
.RI "static constexpr uint32_t \fBrol\fP (uint32_t x, uint32_t n)"
.br
.ti -1c
.RI "static constexpr uint32_t \fBrol\fP (uint32_t x, uint32_t n)"
.br
.ti -1c
.RI "static constexpr uint32_t \fBrol\fP (uint32_t x, uint32_t n)"
.br
.ti -1c
.RI "static constexpr uint32_t \fBrol\fP (uint32_t x, uint32_t n)"
.br
.ti -1c
.RI "static constexpr uint32_t \fBrol\fP (uint32_t x, uint32_t n)"
.br
.ti -1c
.RI "static constexpr uint32_t \fBrol\fP (uint32_t x, uint32_t n)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 20 of file Performance_Prime_With_Counter_1\&.cpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "BitArray::BitArray (size_t size)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line 40 of file Performance_Prime_With_Counter_1\&.cpp\&.
.PP
.nf
40                                    : arrSize(size) {
41         array = new uint32_t[arraySize(size)];
42         std::memset(array, 0xFF, (size >> 3) + ((size & 7) > 0));
43     }
.fi
.SS "BitArray::~BitArray ()\fC [inline]\fP"

.PP
Definition at line 45 of file Performance_Prime_With_Counter_1\&.cpp\&.
.PP
.nf
45 {delete [] array;}
.fi
.SS "BitArray::BitArray (size_t size)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line 40 of file Performance_Prime_With_Counter_2\&.cpp\&.
.PP
.nf
40                                    : arrSize(size) {
41         array = new uint32_t[arraySize(size)];
42         std::memset(array, 0xFF, (size >> 3) + ((size & 7) > 0));
43     }
.fi
.SS "BitArray::~BitArray ()\fC [inline]\fP"

.PP
Definition at line 45 of file Performance_Prime_With_Counter_2\&.cpp\&.
.PP
.nf
45 {delete [] array;}
.fi
.SS "BitArray::BitArray (size_t size)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line 40 of file Performance_Prime_With_Counter_3\&.cpp\&.
.PP
.nf
40                                    : arrSize(size) {
41         array = new uint32_t[arraySize(size)];
42         std::memset(array, 0xFF, (size >> 3) + ((size & 7) > 0));
43     }
.fi
.SS "BitArray::~BitArray ()\fC [inline]\fP"

.PP
Definition at line 45 of file Performance_Prime_With_Counter_3\&.cpp\&.
.PP
.nf
45 {delete [] array;}
.fi
.SS "BitArray::BitArray (size_t size)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line 40 of file Performance_Prime_With_Counter_4\&.cpp\&.
.PP
.nf
40                                    : arrSize(size) {
41         array = new uint32_t[arraySize(size)];
42         std::memset(array, 0xFF, (size >> 3) + ((size & 7) > 0));
43     }
.fi
.SS "BitArray::~BitArray ()\fC [inline]\fP"

.PP
Definition at line 45 of file Performance_Prime_With_Counter_4\&.cpp\&.
.PP
.nf
45 {delete [] array;}
.fi
.SS "BitArray::BitArray (size_t size)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line 40 of file Performance_Prime_With_Counter_5\&.cpp\&.
.PP
.nf
40                                    : arrSize(size) {
41         array = new uint32_t[arraySize(size)];
42         std::memset(array, 0xFF, (size >> 3) + ((size & 7) > 0));
43     }
.fi
.SS "BitArray::~BitArray ()\fC [inline]\fP"

.PP
Definition at line 45 of file Performance_Prime_With_Counter_5\&.cpp\&.
.PP
.nf
45 {delete [] array;}
.fi
.SS "BitArray::BitArray (size_t size)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line 40 of file Performance_Prime_With_Counter_6\&.cpp\&.
.PP
.nf
40                                    : arrSize(size) {
41         array = new uint32_t[arraySize(size)];
42         std::memset(array, 0xFF, (size >> 3) + ((size & 7) > 0));
43     }
.fi
.SS "BitArray::~BitArray ()\fC [inline]\fP"

.PP
Definition at line 45 of file Performance_Prime_With_Counter_6\&.cpp\&.
.PP
.nf
45 {delete [] array;}
.fi
.SS "BitArray::BitArray (size_t size)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line 39 of file Performance_Prime_Without_Counter\&.cpp\&.
.PP
.nf
39                                    : arrSize(size) {
40         array = new uint32_t[arraySize(size)];
41         std::memset(array, 0xFF, (size >> 3) + ((size & 7) > 0));
42     }
.fi
.SS "BitArray::~BitArray ()\fC [inline]\fP"

.PP
Definition at line 44 of file Performance_Prime_Without_Counter\&.cpp\&.
.PP
.nf
44 {delete [] array;}
.fi
.SH "Member Function Documentation"
.PP 
.SS "bool BitArray::get (size_t n) const\fC [inline]\fP"

.PP
Definition at line 47 of file Performance_Prime_With_Counter_1\&.cpp\&.
.PP
.nf
47                              {
48         return getSubindex(n, array[index(n)]);
49     }
.fi
.PP
Referenced by prime_sieve::countPrimes(), prime_sieve::printResults(), and prime_sieve::runSieve()\&.
.SS "bool BitArray::get (size_t n) const\fC [inline]\fP"

.PP
Definition at line 47 of file Performance_Prime_With_Counter_2\&.cpp\&.
.PP
.nf
47                              {
48         return getSubindex(n, array[index(n)]);
49     }
.fi
.SS "bool BitArray::get (size_t n) const\fC [inline]\fP"

.PP
Definition at line 47 of file Performance_Prime_With_Counter_3\&.cpp\&.
.PP
.nf
47                              {
48         return getSubindex(n, array[index(n)]);
49     }
.fi
.SS "bool BitArray::get (size_t n) const\fC [inline]\fP"

.PP
Definition at line 47 of file Performance_Prime_With_Counter_4\&.cpp\&.
.PP
.nf
47                              {
48         return getSubindex(n, array[index(n)]);
49     }
.fi
.SS "bool BitArray::get (size_t n) const\fC [inline]\fP"

.PP
Definition at line 47 of file Performance_Prime_With_Counter_5\&.cpp\&.
.PP
.nf
47                              {
48         return getSubindex(n, array[index(n)]);
49     }
.fi
.SS "bool BitArray::get (size_t n) const\fC [inline]\fP"

.PP
Definition at line 47 of file Performance_Prime_With_Counter_6\&.cpp\&.
.PP
.nf
47                              {
48         return getSubindex(n, array[index(n)]);
49     }
.fi
.SS "bool BitArray::get (size_t n) const\fC [inline]\fP"

.PP
Definition at line 46 of file Performance_Prime_Without_Counter\&.cpp\&.
.PP
.nf
46                              {
47         return getSubindex(n, array[index(n)]);
48     }
.fi
.SS "static constexpr uint32_t BitArray::rol (uint32_t x, uint32_t n)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
Definition at line 51 of file Performance_Prime_With_Counter_1\&.cpp\&.
.PP
.nf
51                                                           {
52         return (x<<n) | (x>>(32-n));
53     }
.fi
.SS "static constexpr uint32_t BitArray::rol (uint32_t x, uint32_t n)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
Definition at line 51 of file Performance_Prime_With_Counter_2\&.cpp\&.
.PP
.nf
51                                                           {
52         return (x<<n) | (x>>(32-n));
53     }
.fi
.SS "static constexpr uint32_t BitArray::rol (uint32_t x, uint32_t n)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
Definition at line 51 of file Performance_Prime_With_Counter_3\&.cpp\&.
.PP
.nf
51                                                           {
52         return (x<<n) | (x>>(32-n));
53     }
.fi
.SS "static constexpr uint32_t BitArray::rol (uint32_t x, uint32_t n)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
Definition at line 51 of file Performance_Prime_With_Counter_4\&.cpp\&.
.PP
.nf
51                                                           {
52         return (x<<n) | (x>>(32-n));
53     }
.fi
.SS "static constexpr uint32_t BitArray::rol (uint32_t x, uint32_t n)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
Definition at line 51 of file Performance_Prime_With_Counter_5\&.cpp\&.
.PP
.nf
51                                                           {
52         return (x<<n) | (x>>(32-n));
53     }
.fi
.SS "static constexpr uint32_t BitArray::rol (uint32_t x, uint32_t n)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
Definition at line 51 of file Performance_Prime_With_Counter_6\&.cpp\&.
.PP
.nf
51                                                           {
52         return (x<<n) | (x>>(32-n));
53     }
.fi
.SS "static constexpr uint32_t BitArray::rol (uint32_t x, uint32_t n)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
Definition at line 50 of file Performance_Prime_Without_Counter\&.cpp\&.
.PP
.nf
50                                                           {
51         return (x<<n) | (x>>(32-n));
52     }
.fi
.SS "void BitArray::setFlagsFalse (size_t n, size_t skip)\fC [inline]\fP"

.PP
Definition at line 55 of file Performance_Prime_With_Counter_1\&.cpp\&.
.PP
.nf
55                                               {
56         auto rolling_mask = ~uint32_t(1 << n % 32);
57         auto roll_bits = skip % 32;
58         while (n < arrSize) {
59             array[index(n)] &= rolling_mask;
60             n += skip;
61             rolling_mask = rol(rolling_mask, roll_bits);
62         }
63     }
.fi
.PP
Referenced by prime_sieve::runSieve()\&.
.SS "void BitArray::setFlagsFalse (size_t n, size_t skip)\fC [inline]\fP"

.PP
Definition at line 55 of file Performance_Prime_With_Counter_2\&.cpp\&.
.PP
.nf
55                                               {
56         auto rolling_mask = ~uint32_t(1 << n % 32);
57         auto roll_bits = skip % 32;
58         while (n < arrSize) {
59             array[index(n)] &= rolling_mask;
60             n += skip;
61             rolling_mask = rol(rolling_mask, roll_bits);
62         }
63     }
.fi
.SS "void BitArray::setFlagsFalse (size_t n, size_t skip)\fC [inline]\fP"

.PP
Definition at line 55 of file Performance_Prime_With_Counter_3\&.cpp\&.
.PP
.nf
55                                               {
56         auto rolling_mask = ~uint32_t(1 << n % 32);
57         auto roll_bits = skip % 32;
58         while (n < arrSize) {
59             array[index(n)] &= rolling_mask;
60             n += skip;
61             rolling_mask = rol(rolling_mask, roll_bits);
62         }
63     }
.fi
.SS "void BitArray::setFlagsFalse (size_t n, size_t skip)\fC [inline]\fP"

.PP
Definition at line 55 of file Performance_Prime_With_Counter_4\&.cpp\&.
.PP
.nf
55                                               {
56         auto rolling_mask = ~uint32_t(1 << n % 32);
57         auto roll_bits = skip % 32;
58         while (n < arrSize) {
59             array[index(n)] &= rolling_mask;
60             n += skip;
61             rolling_mask = rol(rolling_mask, roll_bits);
62         }
63     }
.fi
.SS "void BitArray::setFlagsFalse (size_t n, size_t skip)\fC [inline]\fP"

.PP
Definition at line 55 of file Performance_Prime_With_Counter_5\&.cpp\&.
.PP
.nf
55                                               {
56         dataStorage\&.startEvent(2);
57 auto rolling_mask = ~uint32_t(1 << n % 32);
58         auto roll_bits = skip % 32;
59         dataStorage\&.endEvent(2);
60 dataStorage\&.startEvent(3);
61 while (n < arrSize) {
62             array[index(n)] &= rolling_mask;
63             n += skip;
64             rolling_mask = rol(rolling_mask, roll_bits);
65         }dataStorage\&.endEvent(3);
66 
67     }
.fi
.PP
References dataStorage(), DataStorage::endEvent(), and DataStorage::startEvent()\&.
.SS "void BitArray::setFlagsFalse (size_t n, size_t skip)\fC [inline]\fP"

.PP
Definition at line 55 of file Performance_Prime_With_Counter_6\&.cpp\&.
.PP
.nf
55                                               {
56         auto rolling_mask = ~uint32_t(1 << n % 32);
57         auto roll_bits = skip % 32;
58         dataStorage\&.startEvent(1);
59 while (n < arrSize) {
60             dataStorage\&.startEvent(2);
61 array[index(n)] &= rolling_mask;
62             n += skip;
63             rolling_mask = rol(rolling_mask, roll_bits);
64 dataStorage\&.endEvent(2);
65         }dataStorage\&.endEvent(1);
66 
67     }
.fi
.PP
References dataStorage(), DataStorage::endEvent(), and DataStorage::startEvent()\&.
.SS "void BitArray::setFlagsFalse (size_t n, size_t skip)\fC [inline]\fP"

.PP
Definition at line 54 of file Performance_Prime_Without_Counter\&.cpp\&.
.PP
.nf
54                                               {
55         auto rolling_mask = ~uint32_t(1 << n % 32);
56         auto roll_bits = skip % 32;
57         while (n < arrSize) {
58             array[index(n)] &= rolling_mask;
59             n += skip;
60             rolling_mask = rol(rolling_mask, roll_bits);
61         }
62     }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for Regions Of Interest (ROI) Profiler from the source code\&.
