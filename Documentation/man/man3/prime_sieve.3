.TH "prime_sieve" 3 "Sat Feb 12 2022" "Version 1.2" "Regions Of Interest (ROI) Profiler" \" -*- nroff -*-
.ad l
.nh
.SH NAME
prime_sieve
.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBprime_sieve\fP (long n)"
.br
.ti -1c
.RI "\fB~prime_sieve\fP ()"
.br
.ti -1c
.RI "void \fBrunSieve\fP ()"
.br
.ti -1c
.RI "void \fBprintResults\fP (bool showResults, double duration, int passes)"
.br
.ti -1c
.RI "int \fBcountPrimes\fP ()"
.br
.ti -1c
.RI "\fBprime_sieve\fP (long n)"
.br
.ti -1c
.RI "\fB~prime_sieve\fP ()"
.br
.ti -1c
.RI "void \fBrunSieve\fP ()"
.br
.ti -1c
.RI "void \fBprintResults\fP (bool showResults, double duration, int passes)"
.br
.ti -1c
.RI "int \fBcountPrimes\fP ()"
.br
.ti -1c
.RI "\fBprime_sieve\fP (long n)"
.br
.ti -1c
.RI "\fB~prime_sieve\fP ()"
.br
.ti -1c
.RI "void \fBrunSieve\fP ()"
.br
.ti -1c
.RI "void \fBprintResults\fP (bool showResults, double duration, int passes)"
.br
.ti -1c
.RI "int \fBcountPrimes\fP ()"
.br
.ti -1c
.RI "\fBprime_sieve\fP (long n)"
.br
.ti -1c
.RI "\fB~prime_sieve\fP ()"
.br
.ti -1c
.RI "void \fBrunSieve\fP ()"
.br
.ti -1c
.RI "void \fBprintResults\fP (bool showResults, double duration, int passes)"
.br
.ti -1c
.RI "int \fBcountPrimes\fP ()"
.br
.ti -1c
.RI "\fBprime_sieve\fP (long n)"
.br
.ti -1c
.RI "\fB~prime_sieve\fP ()"
.br
.ti -1c
.RI "void \fBrunSieve\fP ()"
.br
.ti -1c
.RI "void \fBprintResults\fP (bool showResults, double duration, int passes)"
.br
.ti -1c
.RI "int \fBcountPrimes\fP ()"
.br
.ti -1c
.RI "\fBprime_sieve\fP (long n)"
.br
.ti -1c
.RI "\fB~prime_sieve\fP ()"
.br
.ti -1c
.RI "void \fBrunSieve\fP ()"
.br
.ti -1c
.RI "void \fBprintResults\fP (bool showResults, double duration, int passes)"
.br
.ti -1c
.RI "int \fBcountPrimes\fP ()"
.br
.ti -1c
.RI "\fBprime_sieve\fP (long n)"
.br
.ti -1c
.RI "\fB~prime_sieve\fP ()"
.br
.ti -1c
.RI "void \fBrunSieve\fP ()"
.br
.ti -1c
.RI "void \fBprintResults\fP (bool showResults, double duration, int passes)"
.br
.ti -1c
.RI "int \fBcountPrimes\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 66 of file Performance_Prime_With_Counter_1\&.cpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "prime_sieve::prime_sieve (long n)\fC [inline]\fP"

.PP
Definition at line 84 of file Performance_Prime_With_Counter_1\&.cpp\&.
.PP
.nf
85         : Bits(n), sieveSize(n)
86       {
87       }
.fi
.SS "prime_sieve::~prime_sieve ()\fC [inline]\fP"

.PP
Definition at line 89 of file Performance_Prime_With_Counter_1\&.cpp\&.
.PP
.nf
90       {
91       }
.fi
.SS "prime_sieve::prime_sieve (long n)\fC [inline]\fP"

.PP
Definition at line 84 of file Performance_Prime_With_Counter_2\&.cpp\&.
.PP
.nf
85         : Bits(n), sieveSize(n)
86       {
87       }
.fi
.SS "prime_sieve::~prime_sieve ()\fC [inline]\fP"

.PP
Definition at line 89 of file Performance_Prime_With_Counter_2\&.cpp\&.
.PP
.nf
90       {
91       }
.fi
.SS "prime_sieve::prime_sieve (long n)\fC [inline]\fP"

.PP
Definition at line 84 of file Performance_Prime_With_Counter_3\&.cpp\&.
.PP
.nf
85         : Bits(n), sieveSize(n)
86       {
87       }
.fi
.SS "prime_sieve::~prime_sieve ()\fC [inline]\fP"

.PP
Definition at line 89 of file Performance_Prime_With_Counter_3\&.cpp\&.
.PP
.nf
90       {
91       }
.fi
.SS "prime_sieve::prime_sieve (long n)\fC [inline]\fP"

.PP
Definition at line 84 of file Performance_Prime_With_Counter_4\&.cpp\&.
.PP
.nf
85         : Bits(n), sieveSize(n)
86       {
87       }
.fi
.SS "prime_sieve::~prime_sieve ()\fC [inline]\fP"

.PP
Definition at line 89 of file Performance_Prime_With_Counter_4\&.cpp\&.
.PP
.nf
90       {
91       }
.fi
.SS "prime_sieve::prime_sieve (long n)\fC [inline]\fP"

.PP
Definition at line 88 of file Performance_Prime_With_Counter_5\&.cpp\&.
.PP
.nf
89         : Bits(n), sieveSize(n)
90       {
91       }
.fi
.SS "prime_sieve::~prime_sieve ()\fC [inline]\fP"

.PP
Definition at line 93 of file Performance_Prime_With_Counter_5\&.cpp\&.
.PP
.nf
94       {
95       }
.fi
.SS "prime_sieve::prime_sieve (long n)\fC [inline]\fP"

.PP
Definition at line 88 of file Performance_Prime_With_Counter_6\&.cpp\&.
.PP
.nf
89         : Bits(n), sieveSize(n)
90       {
91       }
.fi
.SS "prime_sieve::~prime_sieve ()\fC [inline]\fP"

.PP
Definition at line 93 of file Performance_Prime_With_Counter_6\&.cpp\&.
.PP
.nf
94       {
95       }
.fi
.SS "prime_sieve::prime_sieve (long n)\fC [inline]\fP"

.PP
Definition at line 83 of file Performance_Prime_Without_Counter\&.cpp\&.
.PP
.nf
84         : Bits(n), sieveSize(n)
85       {
86       }
.fi
.SS "prime_sieve::~prime_sieve ()\fC [inline]\fP"

.PP
Definition at line 88 of file Performance_Prime_Without_Counter\&.cpp\&.
.PP
.nf
89       {
90       }
.fi
.SH "Member Function Documentation"
.PP 
.SS "int prime_sieve::countPrimes ()\fC [inline]\fP"

.PP
Definition at line 150 of file Performance_Prime_With_Counter_1\&.cpp\&.
.PP
.nf
151       {
152           int count =  (sieveSize >= 2);;
153           for (int i = 3; i < sieveSize; i+=2)
154               if (Bits\&.get(i))
155                   count++;
156           return count;
157       }
.fi
.PP
References BitArray::get()\&.
.SS "int prime_sieve::countPrimes ()\fC [inline]\fP"

.PP
Definition at line 150 of file Performance_Prime_With_Counter_2\&.cpp\&.
.PP
.nf
151       {
152           int count =  (sieveSize >= 2);;
153           for (int i = 3; i < sieveSize; i+=2)
154               if (Bits\&.get(i))
155                   count++;
156           return count;
157       }
.fi
.PP
References BitArray::get()\&.
.SS "int prime_sieve::countPrimes ()\fC [inline]\fP"

.PP
Definition at line 154 of file Performance_Prime_With_Counter_3\&.cpp\&.
.PP
.nf
155       {
156           int count =  (sieveSize >= 2);;
157           for (int i = 3; i < sieveSize; i+=2)
158               if (Bits\&.get(i))
159                   count++;
160           return count;
161       }
.fi
.PP
References BitArray::get()\&.
.SS "int prime_sieve::countPrimes ()\fC [inline]\fP"

.PP
Definition at line 158 of file Performance_Prime_With_Counter_4\&.cpp\&.
.PP
.nf
159       {
160           int count =  (sieveSize >= 2);;
161           for (int i = 3; i < sieveSize; i+=2)
162               if (Bits\&.get(i))
163                   count++;
164           return count;
165       }
.fi
.PP
References BitArray::get()\&.
.SS "int prime_sieve::countPrimes ()\fC [inline]\fP"

.PP
Definition at line 156 of file Performance_Prime_With_Counter_5\&.cpp\&.
.PP
.nf
157       {
158           int count =  (sieveSize >= 2);;
159           for (int i = 3; i < sieveSize; i+=2)
160               if (Bits\&.get(i))
161                   count++;
162           return count;
163       }
.fi
.PP
References BitArray::get()\&.
.SS "int prime_sieve::countPrimes ()\fC [inline]\fP"

.PP
Definition at line 154 of file Performance_Prime_With_Counter_6\&.cpp\&.
.PP
.nf
155       {
156           int count =  (sieveSize >= 2);;
157           for (int i = 3; i < sieveSize; i+=2)
158               if (Bits\&.get(i))
159                   count++;
160           return count;
161       }
.fi
.PP
References BitArray::get()\&.
.SS "int prime_sieve::countPrimes ()\fC [inline]\fP"

.PP
Definition at line 149 of file Performance_Prime_Without_Counter\&.cpp\&.
.PP
.nf
150       {
151           int count =  (sieveSize >= 2);;
152           for (int i = 3; i < sieveSize; i+=2)
153               if (Bits\&.get(i))
154                   count++;
155           return count;
156       }
.fi
.PP
References BitArray::get()\&.
.SS "void prime_sieve::printResults (bool showResults, double duration, int passes)\fC [inline]\fP"

.PP
Definition at line 114 of file Performance_Prime_With_Counter_1\&.cpp\&.
.PP
.nf
115       {
116           if (showResults)
117               printf("2, ");
118 
119           int count = (sieveSize >= 2);                             // Starting count (2 is prime)
120           for (int num = 3; num <= sieveSize; num+=2)
121           {
122               if (Bits\&.get(num))
123               {
124                   if (showResults)
125                       printf("%d, ", num);
126                   count++;
127               }
128           }
129 
130           if (showResults)
131               printf("\n");
132 
133           ofstream outfile;
134           outfile\&.open("Time_Performance_Prime\&.txt", ios_base::app);
135           outfile << passes << "\n";
136           /*printf("Passes: %d, Time: %lf, Avg: %lf, Limit: %ld, Count1: %d, Count2: %d, Valid: %d\n",
137                  passes,
138                  duration,
139                  duration / passes,
140                  sieveSize,
141                  count,
142                  countPrimes(),
143                  validateResults());
144 
145           // Following 2 lines added by rbergen to conform to drag race output format
146           printf("\n");
147           printf("davepl_pol;%d;%f;1;algorithm=base,faithful=yes,bits=1\n", passes, duration);*/
148       }
.fi
.PP
References BitArray::get()\&.
.PP
Referenced by main()\&.
.SS "void prime_sieve::printResults (bool showResults, double duration, int passes)\fC [inline]\fP"

.PP
Definition at line 114 of file Performance_Prime_With_Counter_2\&.cpp\&.
.PP
.nf
115       {
116           if (showResults)
117               printf("2, ");
118 
119           int count = (sieveSize >= 2);                             // Starting count (2 is prime)
120           for (int num = 3; num <= sieveSize; num+=2)
121           {
122               if (Bits\&.get(num))
123               {
124                   if (showResults)
125                       printf("%d, ", num);
126                   count++;
127               }
128           }
129 
130           if (showResults)
131               printf("\n");
132 
133           ofstream outfile;
134           outfile\&.open("Time_Performance_Prime\&.txt", ios_base::app);
135           outfile << passes << "\n";
136           /*printf("Passes: %d, Time: %lf, Avg: %lf, Limit: %ld, Count1: %d, Count2: %d, Valid: %d\n",
137                  passes,
138                  duration,
139                  duration / passes,
140                  sieveSize,
141                  count,
142                  countPrimes(),
143                  validateResults());
144 
145           // Following 2 lines added by rbergen to conform to drag race output format
146           printf("\n");
147           printf("davepl_pol;%d;%f;1;algorithm=base,faithful=yes,bits=1\n", passes, duration);*/
148       }
.fi
.PP
References BitArray::get()\&.
.SS "void prime_sieve::printResults (bool showResults, double duration, int passes)\fC [inline]\fP"

.PP
Definition at line 118 of file Performance_Prime_With_Counter_3\&.cpp\&.
.PP
.nf
119       {
120           if (showResults)
121               printf("2, ");
122 
123           int count = (sieveSize >= 2);                             // Starting count (2 is prime)
124           for (int num = 3; num <= sieveSize; num+=2)
125           {
126               if (Bits\&.get(num))
127               {
128                   if (showResults)
129                       printf("%d, ", num);
130                   count++;
131               }
132           }
133 
134           if (showResults)
135               printf("\n");
136 
137           ofstream outfile;
138           outfile\&.open("Time_Performance_Prime\&.txt", ios_base::app);
139           outfile << passes << "\n";
140           /*printf("Passes: %d, Time: %lf, Avg: %lf, Limit: %ld, Count1: %d, Count2: %d, Valid: %d\n",
141                  passes,
142                  duration,
143                  duration / passes,
144                  sieveSize,
145                  count,
146                  countPrimes(),
147                  validateResults());
148 
149           // Following 2 lines added by rbergen to conform to drag race output format
150           printf("\n");
151           printf("davepl_pol;%d;%f;1;algorithm=base,faithful=yes,bits=1\n", passes, duration);*/
152       }
.fi
.PP
References BitArray::get()\&.
.SS "void prime_sieve::printResults (bool showResults, double duration, int passes)\fC [inline]\fP"

.PP
Definition at line 122 of file Performance_Prime_With_Counter_4\&.cpp\&.
.PP
.nf
123       {
124           if (showResults)
125               printf("2, ");
126 
127           int count = (sieveSize >= 2);                             // Starting count (2 is prime)
128           for (int num = 3; num <= sieveSize; num+=2)
129           {
130               if (Bits\&.get(num))
131               {
132                   if (showResults)
133                       printf("%d, ", num);
134                   count++;
135               }
136           }
137 
138           if (showResults)
139               printf("\n");
140 
141           ofstream outfile;
142           outfile\&.open("Time_Performance_Prime\&.txt", ios_base::app);
143           outfile << passes << "\n";
144           /*printf("Passes: %d, Time: %lf, Avg: %lf, Limit: %ld, Count1: %d, Count2: %d, Valid: %d\n",
145                  passes,
146                  duration,
147                  duration / passes,
148                  sieveSize,
149                  count,
150                  countPrimes(),
151                  validateResults());
152 
153           // Following 2 lines added by rbergen to conform to drag race output format
154           printf("\n");
155           printf("davepl_pol;%d;%f;1;algorithm=base,faithful=yes,bits=1\n", passes, duration);*/
156       }
.fi
.PP
References BitArray::get()\&.
.SS "void prime_sieve::printResults (bool showResults, double duration, int passes)\fC [inline]\fP"

.PP
Definition at line 120 of file Performance_Prime_With_Counter_5\&.cpp\&.
.PP
.nf
121       {
122           if (showResults)
123               printf("2, ");
124 
125           int count = (sieveSize >= 2);                             // Starting count (2 is prime)
126           for (int num = 3; num <= sieveSize; num+=2)
127           {
128               if (Bits\&.get(num))
129               {
130                   if (showResults)
131                       printf("%d, ", num);
132                   count++;
133               }
134           }
135 
136           if (showResults)
137               printf("\n");
138 
139           ofstream outfile;
140           outfile\&.open("Time_Performance_Prime\&.txt", ios_base::app);
141           outfile << passes << "\n";
142           /*printf("Passes: %d, Time: %lf, Avg: %lf, Limit: %ld, Count1: %d, Count2: %d, Valid: %d\n",
143                  passes,
144                  duration,
145                  duration / passes,
146                  sieveSize,
147                  count,
148                  countPrimes(),
149                  validateResults());
150 
151           // Following 2 lines added by rbergen to conform to drag race output format
152           printf("\n");
153           printf("davepl_pol;%d;%f;1;algorithm=base,faithful=yes,bits=1\n", passes, duration);*/
154       }
.fi
.PP
References BitArray::get()\&.
.SS "void prime_sieve::printResults (bool showResults, double duration, int passes)\fC [inline]\fP"

.PP
Definition at line 118 of file Performance_Prime_With_Counter_6\&.cpp\&.
.PP
.nf
119       {
120           if (showResults)
121               printf("2, ");
122 
123           int count = (sieveSize >= 2);                             // Starting count (2 is prime)
124           for (int num = 3; num <= sieveSize; num+=2)
125           {
126               if (Bits\&.get(num))
127               {
128                   if (showResults)
129                       printf("%d, ", num);
130                   count++;
131               }
132           }
133 
134           if (showResults)
135               printf("\n");
136 
137           ofstream outfile;
138           outfile\&.open("Time_Performance_Prime\&.txt", ios_base::app);
139           outfile << passes << "\n";
140           /*printf("Passes: %d, Time: %lf, Avg: %lf, Limit: %ld, Count1: %d, Count2: %d, Valid: %d\n",
141                  passes,
142                  duration,
143                  duration / passes,
144                  sieveSize,
145                  count,
146                  countPrimes(),
147                  validateResults());
148 
149           // Following 2 lines added by rbergen to conform to drag race output format
150           printf("\n");
151           printf("davepl_pol;%d;%f;1;algorithm=base,faithful=yes,bits=1\n", passes, duration);*/
152       }
.fi
.PP
References BitArray::get()\&.
.SS "void prime_sieve::printResults (bool showResults, double duration, int passes)\fC [inline]\fP"

.PP
Definition at line 113 of file Performance_Prime_Without_Counter\&.cpp\&.
.PP
.nf
114       {
115           if (showResults)
116               printf("2, ");
117 
118           int count = (sieveSize >= 2);                             // Starting count (2 is prime)
119           for (int num = 3; num <= sieveSize; num+=2)
120           {
121               if (Bits\&.get(num))
122               {
123                   if (showResults)
124                       printf("%d, ", num);
125                   count++;
126               }
127           }
128 
129           if (showResults)
130               printf("\n");
131 
132           ofstream outfile;
133           outfile\&.open("Time_Performance_Prime\&.txt", ios_base::app);
134           outfile << passes << "\n";
135           /*printf("Passes: %d, Time: %lf, Avg: %lf, Limit: %ld, Count1: %d, Count2: %d, Valid: %d\n",
136                  passes,
137                  duration,
138                  duration / passes,
139                  sieveSize,
140                  count,
141                  countPrimes(),
142                  validateResults());
143 
144           // Following 2 lines added by rbergen to conform to drag race output format
145           printf("\n");
146           printf("davepl_pol;%d;%f;1;algorithm=base,faithful=yes,bits=1\n", passes, duration);*/
147       }
.fi
.PP
References BitArray::get()\&.
.SS "void prime_sieve::runSieve ()\fC [inline]\fP"

.PP
Definition at line 93 of file Performance_Prime_With_Counter_1\&.cpp\&.
.PP
.nf
94       {
95           int factor = 3;
96           int q = (int) sqrt(sieveSize);
97 
98           while (factor <= q)
99           {
100               for (int num = factor; num < sieveSize; num += 2)
101               {
102                   if (Bits\&.get(num))
103                   {
104                       factor = num;
105                       break;
106                   }
107               }
108               Bits\&.setFlagsFalse(factor * factor, factor + factor);
109 
110               factor += 2;
111           }
112       }
.fi
.PP
References BitArray::get(), and BitArray::setFlagsFalse()\&.
.PP
Referenced by main()\&.
.SS "void prime_sieve::runSieve ()\fC [inline]\fP"

.PP
Definition at line 93 of file Performance_Prime_With_Counter_2\&.cpp\&.
.PP
.nf
94       {
95           int factor = 3;
96           int q = (int) sqrt(sieveSize);
97 
98           while (factor <= q)
99           {
100               for (int num = factor; num < sieveSize; num += 2)
101               {
102                   if (Bits\&.get(num))
103                   {
104                       factor = num;
105                       break;
106                   }
107               }
108               Bits\&.setFlagsFalse(factor * factor, factor + factor);
109 
110               factor += 2;
111           }
112       }
.fi
.PP
References BitArray::get(), and BitArray::setFlagsFalse()\&.
.SS "void prime_sieve::runSieve ()\fC [inline]\fP"

.PP
Definition at line 93 of file Performance_Prime_With_Counter_3\&.cpp\&.
.PP
.nf
94       {
95           dataStorage\&.startEvent(2);
96 int factor = 3;
97           int q = (int) sqrt(sieveSize);
98 
99           dataStorage\&.endEvent(2);
100 dataStorage\&.startEvent(3);
101 while (factor <= q)
102           {
103               for (int num = factor; num < sieveSize; num += 2)
104               {
105                   if (Bits\&.get(num))
106                   {
107                       factor = num;
108                       break;
109                   }
110               }
111               Bits\&.setFlagsFalse(factor * factor, factor + factor);
112 
113               factor += 2;
114           }dataStorage\&.endEvent(3);
115 
116       }
.fi
.PP
References dataStorage(), DataStorage::endEvent(), BitArray::get(), BitArray::setFlagsFalse(), and DataStorage::startEvent()\&.
.SS "void prime_sieve::runSieve ()\fC [inline]\fP"

.PP
Definition at line 93 of file Performance_Prime_With_Counter_4\&.cpp\&.
.PP
.nf
94       {
95           int factor = 3;
96           int q = (int) sqrt(sieveSize);
97 
98           dataStorage\&.startEvent(1);
99 while (factor <= q)
100           {
101               dataStorage\&.startEvent(2);
102 for (int num = factor; num < sieveSize; num += 2)
103               {
104                   if (Bits\&.get(num))
105                   {
106                       factor = num;
107                       break;
108                   }
109               }
110 dataStorage\&.endEvent(2);
111               dataStorage\&.startEvent(3);
112 Bits\&.setFlagsFalse(factor * factor, factor + factor);
113 dataStorage\&.endEvent(3);
114 
115               dataStorage\&.startEvent(4);
116 factor += 2;
117 dataStorage\&.endEvent(4);
118           }dataStorage\&.endEvent(1);
119 
120       }
.fi
.PP
References dataStorage(), DataStorage::endEvent(), BitArray::get(), BitArray::setFlagsFalse(), and DataStorage::startEvent()\&.
.SS "void prime_sieve::runSieve ()\fC [inline]\fP"

.PP
Definition at line 97 of file Performance_Prime_With_Counter_5\&.cpp\&.
.PP
.nf
98       {
99           int factor = 3;
100           int q = (int) sqrt(sieveSize);
101 
102           while (factor <= q)
103           {
104               for (int num = factor; num < sieveSize; num += 2)
105               {
106                   if (Bits\&.get(num))
107                   {
108                       factor = num;
109                       break;
110                   }
111               }
112               dataStorage\&.startEvent(1);
113 Bits\&.setFlagsFalse(factor * factor, factor + factor);
114 dataStorage\&.endEvent(1);
115 
116               factor += 2;
117           }
118       }
.fi
.PP
References dataStorage(), DataStorage::endEvent(), BitArray::get(), BitArray::setFlagsFalse(), and DataStorage::startEvent()\&.
.SS "void prime_sieve::runSieve ()\fC [inline]\fP"

.PP
Definition at line 97 of file Performance_Prime_With_Counter_6\&.cpp\&.
.PP
.nf
98       {
99           int factor = 3;
100           int q = (int) sqrt(sieveSize);
101 
102           while (factor <= q)
103           {
104               for (int num = factor; num < sieveSize; num += 2)
105               {
106                   if (Bits\&.get(num))
107                   {
108                       factor = num;
109                       break;
110                   }
111               }
112               Bits\&.setFlagsFalse(factor * factor, factor + factor);
113 
114               factor += 2;
115           }
116       }
.fi
.PP
References BitArray::get(), and BitArray::setFlagsFalse()\&.
.SS "void prime_sieve::runSieve ()\fC [inline]\fP"

.PP
Definition at line 92 of file Performance_Prime_Without_Counter\&.cpp\&.
.PP
.nf
93       {
94           int factor = 3;
95           int q = (int) sqrt(sieveSize);
96 
97           while (factor <= q)
98           {
99               for (int num = factor; num < sieveSize; num += 2)
100               {
101                   if (Bits\&.get(num))
102                   {
103                       factor = num;
104                       break;
105                   }
106               }
107               Bits\&.setFlagsFalse(factor * factor, factor + factor);
108 
109               factor += 2;
110           }
111       }
.fi
.PP
References BitArray::get(), and BitArray::setFlagsFalse()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Regions Of Interest (ROI) Profiler from the source code\&.
